
# Ph.D. Proposal

<https://acuarica.gitlab.io/phd-proposal/phd-proposal.pdf>

## Thesis TODOs

* TODO: Talk about reflection as a way to /escape/ the type system, then talk about casting as a subset of reflection
* TODO: Add discussion from <https://martinfowler.com/bliki/DynamicTyping.html>
* TODO: Discuss "Static Typing of Complex Presence Constraints in Interfaces" \cite{oostvogelsStaticTypingComplex2018a}
* TODO: Source of information for cast success: Config files, libraries, more complex analysis
* TODO: What does the compiler need to know to assert that a cast won't fail at runtime?
* TODO: Include type system soundness discussion for thesis
* TODO: Find examples where \code{instanceof} is right and wrong
* TODO: Quantify patterns, Qualitative data
* TODO: Expand comment on usages of C \code{goto}s in GitHub (similar to our cast study)
* TODO: What conclusions did they draw on JNI usage?
* TODO: Expand discussion on static vs. dynamic analyses for these kinds of studies
* TODO: How many JEPs have been adopted since 2015?
* TODO: Discuss "static vs. dynamic" over "staging-time vs. compile-time vs. link-time vs. load-time vs. run-time"
* TODO: Preliminary discussion about `checkcast` and `instanceof` bytecodes
* TODO: Comment about why source code is necessary: upcasts are lost during compilation
* TODO: Add Code Recommenders Systems Codota/Kite https://www.codota.com/
* TODO: Patterns discussion `Selection`: Implicits in Scala
* TODO: Pattern discussion `Pattern Matching`: Jurgen Vinju paper <http://homepages.cwi.nl/~storm/publications/visitor.pdf>
* TODO: Methodology should be reproducible by other people leading to the same results
* TODO: Cast study coverage
* TODO: Address Antonio's comment on casting is not circumventing the static type system: Dynamically recovery information
* TODO: Make a case for the complexity of Engineering for compiling/dependencies for static analysis
* TODO: Expand on study about the source of exceptions, showing CCE being a problem for developers
* TODO: Pattern Dynamic Proxy: Paper "Static Analysis of Java Dynamic Proxies"
* TODO: Literature Review: Article "Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages"
* TODO: Discussion about *strong typing* in "On understanding types, data abstraction, and polymorphism"
* TODO: Discuss why `classInstanceValue` (square/leakcanary) is not analyzable, deserialization pattern
* TODO: Discuss about `findViewById`: Partial solutions in other languages

* Cast to null
For selection overload. Sometimes, not, they are redundant. For one case, find out in the history why it is redundant.
* Cast int to long
https://lgtm.com/projects/g/apache/commons-io/snapshot/dist-41210059-1524814812150/files/src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java?#L1048

## Literature Review: Add to introduction

* Users/Compilers Java/Scala generated bytecode

But there is more than empirical studies at the source code level.
A machine instruction set is effectively another kind of language.
Therefore, its design can be affected by how compilers generate machine code.
Several studies targeted the \jvm{}~\cite{collberg_empirical_2007,odonoghue_bigram_2002,antonioli_analysis_1998}; while~\cite{cook_empirical_1989} did a similar study for \lilith{} in the past.

## Antonio's comments on the proposal

My first and perhaps most important objections are on the premise of
the main research questions, namely that casting and unsafe are
mechanism used to circumvent the type system.

In particular, I would argue that a down-cast is not a way to
circumvent the type system, but rather a perfectly clear and
straightforward way to work /within/ the type system.

The /Unsafe/ mechanism can do a lot more than messing around with
types, so I wonder in what way the use of /Unsafe/ can be
characterized as a way to circumvent the type system.  Of the 14 usage
patterns listed in Table 3.1, only two have something to do with the
type system, namely throwing undeclared exceptions and updating
/final/ fields -- and those don't seem to be significant breaches of
the type systems anyway.

The examples listed in Section 4.1 don't seem to indicate problems
with the type system.  In other words, here ClassCast exceptions
not fundamentally different from, say, NullPointer exceptions.

The percentage of /indirect/ use of /Unsafe/ is not am indication of
the prevalence of bugs, let alone the prevalence of bugs that are
actually due to the use of /Unsafe/.  Perhaps you should look into
that.

It seems to me that you are focusing on a syntactic or anyway
low-level aspect of the use of a programming language.  You should
instead focus on the /semantics/ of a particular use of a language
feature.  For example, you could ask, how often and in what cases do
programmers use bound checks (in using arrays), and are those bad,
perhaps because they make the code less readable, or they are
unnecessary, because the checks are provably unnecessary.

You say that performance is the main motivation for the uses of
Unsafe.  I would argue that the main motivation is instead another
typical one: supporting various forms of application instrumentation
or other application-independent services (e.g., a checkpointing
library).

You say you focus on high-impact uses/features, but you seem to only
use static analysis.  Have you thought about measuring how often
/Unsafe/ is actually used, meaning /dynamically/?  Another, perhaps
more interesting question is how often those uses are identified as
the root cause of failures.

## Gabriele's comments on the proposal

* Chapter 3, only 1% of the projects (817 out of 86k) use the Unsafe API, but they use it a lot (48k usages). Why?

* Is the usage of the Unsafe API a form of technical debt? If yes, do you expect developers to refactor the code using the Usafe API?

* Comment on the limitation of the study in Chapter 3 related to the selection of the subject systems (libraries only)

* Clarify the manual process used to define the taxonomy in Chapter 3 (e.g., what is the confidence level/interval of the manually analyzed sample? how many evaluators have been involved in the process? how did you solve conflicts between evaluators? etc.)

* It would be interesting to look not only to commits fixing a ClassCastException, but also in code review repositories/issue trackers to analyze the developers’ discussion and extract the rationale behind some implementation choices.

* Consider using the explicit link existing in GitHub between commits and issues to only analyze bug-fixing commits related to ClassCastException (and automatically exclude commits unrelated to bug-fixing activities).

* Look at the 2019 MSR challenge dataset. It reports discussions on Stack Overflow including their code snippets linked to projects in GitHub. You can see whether a given code snippet in SO has been reused in GitHub projects and this can give you some hints on why developers use the Unsafe API or some type cast patterns.

# Sampling

N = Total number of casts to analyze: 9,030,852
K = Total number of casts of the least used pattern
n = Sample size to select
k = Times we saw the least used cast from the sample: 0 meaning we do not see it in our sample

https://keisan.casio.com/exec/system/1180573201

* Cite Unsafe in Related Work.
* DONE: Cite Pierce in the introduction of the casts chapter
* TODO: Tagging for casts
* DONE: Thanks Max for the contributions
* DONE: Test/Gen/App
* TODO: Grouping/Tagging/Patterns+Subpatterns
* TODO: Autodetection of patterns
* TODO: Split UseRawType/RemoveWildcard
* TODO: Statistics/Broken links: More casts until we reach 5000
*** More examples/Longer (not cut)
** Venn Diagram/Groups/UpSet plot
** Tags
*** Type system changes
*** Guarded/Unguarded
*** Audiences: Developers/Designers/Tool Builders
*** Languages Features: Generics/Autobxing/Primitives/Unchecked/Throws
*** More prevalent in: App/Test/Gen
*** Android/API related
*** Need to talk about the approach to analysis. Some very local, some very similar to others. Others require very local analysis. Some even require looking at the project history.




*** Type Erasure
*** "Java Type System hacking/kludge"
** Boxing/Unboxing
*** Cast to force autobox at particular type
*** Narrowing cast from int literal to char/short/byte for call
** Tie "unchecked" casts with blame/gradual typing

** AccessPrivateField: Special mention in SelectOverload
** SoleClassImplementation: Use a better example, ClassImpl implements Inteface

** Example CreateByClassLiteral to GetByClassLiteral

** Typesafe stack for discussion for =StackSymbol= pattern
*** Happy (Haskell parser) unsafe stack easier and faster
*** Implementation w/HList?
*** Second example it is correct because of grammar construction
** TypeTag pattern
*** Last example, check if ~args~ is always ~Object[]~.
*** TypeTag think about reclassifiyng into ?LikelyBug.
** Code Smell into Avoidable?
** Type erasure, Erased category

** Typecase on rethrow because of =throws= declaration
** Logger is a redundant cast

* Threats of validity
** How to handle bias?
* Future Work
QL queries, what queries could be expresses in QL
Patterns as training set and then use ML, code equility

* Levels of locality
** Go beyond the aplication to detect a pattern
** Class/Method






# TypeTag/ClassLiteral


% A cast is using an application-specific guard,
% but the guard depends on a class literal.

% \instances{}
% The following example%
% \footnote{\url{http://bit.ly/elastic_elasticsearch_2SSgsFV}}
% shows an instance of the \thisp{} pattern.
% A cast is performed to the \code{field} variable (line 22),
% based whether the runtime class of the variable is actually \code{Short.class}.

% %https://lgtm.com/projects/g/elastic/elasticsearch/snapshot/dist-1916470085-1524814812150/files/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java?sort=name&dir=ASC&mode=heatmap#L478
% \begin{minted}[highlightlines=22]{java}
% Class type = field.getClass();
% if (type == String.class) {
%     out.writeByte((byte) 1);
%     out.writeString((String) field);
% } else if (type == Integer.class) {
%     out.writeByte((byte) 2);
%     out.writeInt((Integer) field);
% } else if (type == Long.class) {
%     out.writeByte((byte) 3);
%     out.writeLong((Long) field);
% } else if (type == Float.class) {
%     out.writeByte((byte) 4);
%     out.writeFloat((Float) field);
% } else if (type == Double.class) {
%     out.writeByte((byte) 5);
%     out.writeDouble((Double) field);
% } else if (type == Byte.class) {
%     out.writeByte((byte) 6);
%     out.writeByte((Byte) field);
% } else if (type == Short.class) {
%     out.writeByte((byte) 7);
%     out.writeShort((Short) field);
% } else if (type == Boolean.class) {
%     out.writeByte((byte) 8);
%     out.writeBoolean((Boolean) field);
% } else if (type == BytesRef.class) {
%     out.writeByte((byte) 9);
%     out.writeBytesRef((BytesRef) field);
% } else {
%     throw new IOException("Can't handle sort field value of type ["+type+"]");
% }
% \end{minted}

% In the following listing,%
% \footnote{\url{http://bit.ly/smartdevicelink_sdl_android_2EjJiaq}}
% a cast is applied to the result of the \code{getObject} method (line 2).
% The target type of the cast, \code{MyKey}, corresponds to the class literal argument, \code{MyKey.class}.
% Essentially, \code{getObject} is using the \code{isInstance} method%
% \footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\#isInstance-java.lang.Object-}}
% of the class \code{java.lang.Class} to check whether an object is from a certain type.

% %https://lgtm.com/projects/g/smartdevicelink/sdl_android/snapshot/dist-2037360569-1524814812150/files/sdl_android/src/main/java/com/smartdevicelink/proxy/rpc/GetVehicleDataResponse.java?sort=name&dir=ASC&mode=heatmap#L236
% \begin{minted}[highlightlines=2]{java}
% public MyKey getMyKey() {
%     return (MyKey) getObject(MyKey.class, KEY_MY_KEY);
% } 
% \end{minted}

% Similar to the first example, the next snippet%
% \footnote{\url{http://bit.ly/OPCFoundation_UA-Java-Legacy_2Fb2xmZ}}
% contains several type cases.
% Each type case is guarded by an \code{equals} comparison between a class literal and the \code{clazz} parameter.
% The cast is applied to the type parameter \code{T} only if the guard succeeds.

% %https://lgtm.com/projects/g/OPCFoundation/UA-Java-Legacy/snapshot/dist-1804064538-1524814812150/files/src/main/java/org/opcfoundation/ua/encoding/binary/BinaryDecoder.java?sort=name&dir=ASC&mode=heatmap#L214
% \begin{minted}[highlightlines=9]{java}
% @Override
% @SuppressWarnings("unchecked")
% public <T> T get(String fieldName, Class<T> clazz) throws DecodingException {
%     if (clazz.equals(Boolean.class)) {
%         return (T) getBoolean(fieldName);
%     }
%     // [...]
%     if (clazz.equals(ExtensionObject.class)) {
%         return (T) getExtensionObject(fieldName);
%     }
%     // [...]
% }
% \end{minted}

% The following snippet%
% \footnote{\url{http://bit.ly/apache_karaf_2HE55gE}}
% shows an instance of the \thisp{} pattern. 
% In this case, the cast is guaranteed to succeed because the class literal used as argument to the recursive call (\code{Integer.class}) determines that the method returns an \code{int} value.

% %https://lgtm.com/projects/g/apache/karaf/snapshot/dist-13960098-1524814812150/files/shell/core/src/main/java/org/apache/karaf/shell/support/converter/DefaultConverter.java?sort=name&dir=ASC&mode=heatmap#L117
% \begin{minted}[highlightlines=4]{java}
% public Object convertToNumber(Number value, Class toType) throws Exception {
%     toType = unwrap(toType);
%     if (AtomicInteger.class == toType) {
%         return new AtomicInteger((Integer)convertToNumber(value,Integer.class));
%     } else if (AtomicLong.class == toType) {
%         return new AtomicLong((Long) convertToNumber(value, Long.class));
%     } else if (Integer.class == toType) {
%         return value.intValue();
%     } else if (Short.class == toType) {
%         return value.shortValue();
%     } else if (Long.class == toType) {
%         return value.longValue();
%     } else if (Float.class == toType) {
%         return value.floatValue();
%     } else if (Double.class == toType) {
%         return value.doubleValue();
%     } else if (Byte.class == toType) {
%         return value.byteValue();
%     } else if (BigInteger.class == toType) {
%         return new BigInteger(value.toString());
%     } else if (BigDecimal.class == toType) {
%         return new BigDecimal(value.toString());
%     } else {
%         throw new Exception("Unable to convert number "+value+" to "+toType);
%     }
% }
% \end{minted}

% This pattern may be used instead of \nameref{pat:Typecase} when the developer wants to match exactly the runtime class.
% The \code{instanceof} operator%
% \footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html\#jls-15.20.2}}
% returns \code{true} if the expression could be cast to the specified type,
% whereas using a class literal comparison returns \code{true} if the expression is exactly the runtime class.

% As discussed above, it is related to \nameref{pat:Typecase} but this pattern uses an exact match of the runtime class.





% A cast instance belonging to the \thisp{} pattern is guarded by an application-specific test instead of using an \code{instanceof} test.

% The following example%
% \footnote{\url{http://bit.ly/JesusFreke_smali_2Ho8bVL}}
% shows an instance of the \thisp{} pattern.
% The cast type of the parameter \code{reference} is determined by the value of the parameter \code{referenceType}.

% %https://lgtm.com/projects/b/JesusFreke/smali/snapshot/dist-1306230039-1524814812150/files/dexlib2/src/main/java/org/jf/dexlib2/writer/InstructionWriter.java?sort=name&dir=ASC&mode=heatmap#L492
% \begin{minted}[highlightlines=8]{java}
% private int getReferenceIndex(int referenceType, Reference reference) {
%     switch (referenceType) {
%         case ReferenceType.FIELD:
%             return fieldSection.getItemIndex((FieldRefKey) reference);
%         case ReferenceType.METHOD:
%             return methodSection.getItemIndex((MethodRefKey) reference);
%         case ReferenceType.STRING:
%             return stringSection.getItemIndex((StringRef) reference);
%         case ReferenceType.TYPE:
%             return typeSection.getItemIndex((TypeRef) reference);
%         case ReferenceType.METHOD_PROTO:
%             return protoSection.getItemIndex((ProtoRefKey) reference);
%         default:
%             throw new ExceptionWithContext(
%                 "Unknown reference type: %d",  referenceType);
%     }
% }
% \end{minted}

% In the next example,%
% \footnote{\url{http://bit.ly/FenixEdu_fenixedu-academic_2SUNOUJ}}
% instead of a \code{switch} statement,
% an \code{if} statement is used to guard the cast (in line 6).

% %https://lgtm.com/projects/g/FenixEdu/fenixedu-academic/snapshot/dist-29270029-1524814812150/files/src/main/java/org/fenixedu/academic/ui/renderers/student/curriculum/StudentCurricularPlanRenderer.java?sort=name&dir=ASC&mode=heatmap#L853
% \begin{minted}[highlightlines=6]{java}
% for (final IEnrolment enrolment : dismissal.getSourceIEnrolments()) {
%     if (enrolment.isExternalEnrolment()) {
%         generateExternalEnrolmentRow(mainTable, (ExternalEnrolment) enrolment,
%                 level + 1, true);
%     } else {
%         generateEnrolmentRow(mainTable, (Enrolment) enrolment,
%                 level + 1, false, true, true);
%     }
% }
% \end{minted}

% \done{Nate: Why is this not pattern matching?}
% %
% In the next case%
% \footnote{\url{http://bit.ly/apache_poi_2FW5SXU}}
% a type test is performed --- through a method call --- before actually applying the cast to the variable \code{props} (line 3).
% Note that the type test is internally using the \code{instanceof} operator (line 8).
% Although in this case the type test is using an \code{instanceof} operator,
% it is not considered \nameref{pat:Typecase} because the \code{instanceof} is located in a method call.

% %https://lgtm.com/projects/g/apache/poi/snapshot/dist-1790760597-1524814812150/files/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFPropertiesDelegate.java?sort=name&dir=ASC&mode=heatmap#L1367
% \begin{minted}[highlightlines=3]{java}
% @Override
% public CTSolidColorFillProperties getSolidFill() {
%     return isSetSolidFill() ? (CTSolidColorFillProperties)props : null;
% }

% @Override
% public boolean isSetSolidFill() {
%     return (props instanceof CTSolidColorFillProperties);
% }
% \end{minted}

% In some cases, the type to be cast is the same in every branch.
% The following snippet%
% \footnote{\url{http://bit.ly/loopj_android-async-http_2IpIULk}}
% shows an instance of this case.
% The cast is applied to the \code{message.obj} field to (line 13),
% according to the value of the \code{message.what} field (line 1).
% However, a similar cast is applied in the first branch (line 3).
% In both branches \code{message.obj} is of type \code{Object[]},
% but in the case of \code{FAILURE\_MESSAGE},
% the array contains one more element (line 16).
% This suggests that the \code{(Object[]) message.obj} array denotes two different objects,
% but are not distinguishable from the type system perspective.

% %https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1549372228293/files/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap#L359
% \begin{minted}[highlightlines=13]{java}
% switch (message.what) {
%     case SUCCESS_MESSAGE:
%         response = (Object[]) message.obj;
%         if (response != null && response.length >= 3) {
%             onSuccess((Integer) response[0], (Header[]) response[1],
%                     (byte[]) response[2]);
%         } else {
%             AsyncHttpClient.log.e(LOG_TAG, 
%                     "SUCCESS_MESSAGE didn't got enough params");
%         }
%         break;
%     case FAILURE_MESSAGE:
%         response = (Object[]) message.obj;
%         if (response != null && response.length >= 4) {
%             onFailure((Integer) response[0], (Header[]) response[1],
%                     (byte[]) response[2], (Throwable) response[3]);
%         } else {
%             AsyncHttpClient.log.e(LOG_TAG,
%                     "FAILURE_MESSAGE didn't got enough params");
%         }
%         break;
%     // [...]
% }
% \end{minted}

% In the next example,%
% \footnote{\url{http://bit.ly/groovy_groovy-core_2SGzK16}}
% the parameter \code{args} is cast to \code{Object[]} (line 13).
% The ``type tag'' is given by the fact that the cast is executed in a \code{catch} block,
% and that \code{value} is an instance of \code{Closure} (line 9).
% The \code{args} parameter flows into two methods,
% \code{invokeMethod(String name, Object args)}
% and
% \code{call(Object... args)}%
% .
% Thus, \code{args} is treated as an \code{Object} or \code{Object[]} depending on the type tag,
% resembling an union type.

% %https://lgtm.com/projects/g/groovy/groovy-core/snapshot/dist-45390050-1524814812150/files/src/main/groovy/util/Expando.java?sort=name&dir=ASC&mode=heatmap#L103
% \begin{minted}[highlightlines=13]{java}
% public Object invokeMethod(String name, Object args) {
%     try {
%         return super.invokeMethod(name, args);
%     }
%     catch (GroovyRuntimeException e) {
%         // br should get a "native" property match first.
%         // getProperty includes such fall-back logic
%         Object value = this.getProperty(name);
%         if (value instanceof Closure) {
%             Closure closure = (Closure) value;
%             closure = (Closure) closure.clone();
%             closure.setDelegate(this);
%             return closure.call((Object[]) args);
%         } else {
%             throw e;
%         }
%     }
% }
% \end{minted}

% In some cases, the \thisp{} pattern can be replaced by \nameref{pat:Typecase}.
% However, if the application-specific tag is a numeric value,
% the \thisp{} could perform better than the \nameref{pat:Typecase} using \code{instanceof}.
% Moreover, there are situation where the \thisp{} can not be avoid since the types to be cast are the same.

% This pattern is related to \nameref{pat:Typecase} since both denoted guarded casts.
% The difference is that \thisp{} uses an application-specific test.