\section{Validation}
\label{sec:jnif-test}

We used a multitude of testing strategies to ensure \jnif{} is working correctly.

The \jnif{} parser and writer makes no extra modification to the class file, 
thus it is an exact representation of the class file. 
This property makes the parser and writer returns the identical same byte stream which can be useful for testing purposes.


\subsection*{Unit Tests}

\jnif{} includes a unit test suite that tests individual features of its various modules.

\subsection*{Integration Tests}

Our integration test suite includes six different \jnif{} clients we run on over 40000 different classes.
Each test reads, analyses, and possibly modifies, prints, or writes classes from the \java{} runtime library (rt.jar),
and all Dacapo benchmarks, \scala{} benchmarks, and the JRuby compiler.

\begin{description}
\item[testPrinter.]
This test parses and prints all classes.
Its main goal is to cover the printing functionality.
It has no explicit assertions.
We consider it passed if it does not throw any exceptions.
\item[testSize.]
This test covers the decoding and encoding modules.
It asserts that the encoded byte array has the same length as the original byte array.
\item[testWriter.]
This is similar to testSize,
but it asserts that the contents of the encoded byte array is identical to the original bytes.
\item[testNopAdderInstrPrinter.]
This also tests the instrumentation functionality,
by injecting NOP instructions and dumping the result.
It passes if it does not throw any exceptions.
\item[testNopAdderInstrSize.]
This is similar to testSize, however it performs NOP injection.
The resulting size must be identical to the original size plus the size of the injected NOP instructions.
\item[testNopAdderInstrWriter.]
This is similar to testNopAdderInstrSize,
but it asserts that the resulting array is identical except for the modified method bytecodes.
\end{description}

The ``size'' and ``writer'' tests work thanks to the fact that 
\jnif{} produces output identical to its input 
as long as classes are not modified and stack maps do not need to be re-generated.


\subsection*{Live Tests}

Our live tests use \jnif{} inside a \jvmti{} dynamic instrumentation agent
to ensure that the output of \jnif{} can successfully be loaded,
verified, and run by a \jvm{}.
In addition to the aspects covered by the unit and integration tests,
the live tests also validate that stack map generation works correctly,
essentially by using the \jvm{}'s verifier to check correctness.
For the live tests, we run a set of microbenchmarks, 
the Dacapo benchmarks, the Scala Benchmarking Project%
\footnote{\url{http://www.benchmarks.scalabench.org/}},
and a microbenchmark using the JRuby compiler,
with the goal of including InvokeDynamic bytecode instructions generated by JRuby.


\subsection*{Assertions and Checks}

The \jnif{} code is sprinkled with calls to \code{Error::assert} 
that check preconditions, postconditions, and invariants.
To provide a developer experience similar to \java{}'s,
all assertion violations print out call stack traces in addition to understandable error messages.

Moreover, \jnif{} checks its inputs (such as class files while parsing, or instrumented code while generating stack maps),
and it calls \code{Error::check} to throw exceptions with stack traces and helpful messages
when checks fail.
