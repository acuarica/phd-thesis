\section{Using \jnif{}}\label{sec:jnif-usage}

We now briefly show how to use \jnif{}.
\jnif{} can be used both in stand-alone tools or
embedded inside a \jvmti{} agent.
The complete \api{} documentation and more extensive examples are available online%
\footnote{\url{http://acuarica.gitlab.io/jnif/}}.
Listing~\ref{usage-decode-encode} shows how to read and write a class file.

\begin{listing}
\begin{minted}{cpp}
// Decode the binary data into a ClassFile object
const char* data = ...;
int len = ...;
jnif::ClassFile cf(data, len);

// Analyze or edit the ClassFile
...

// Encode the ClassFile into binary
int newlen = cf.computeSize();
u1* newdata = new u1[newlen];
cf.write(newdata, newlen);

// Use newdata and newlen
...

// Free the new binary
delete [] newdata;
\end{minted}
\caption{Decoding and encoding a class}
\label{usage-decode-encode}
\end{listing}

\jnif{}'s \code{ClassFile} class provides fields and methods for analyzing and editing a Java class.
Listing~\ref{usage-print1} shows how to traverse all methods in a class
to dump their names and descriptors.

\begin{listing}
\begin{minted}{cpp}
for (jnif::Method* m : cf.methods) {
  cout << "Method: ";
  cout << cf.getUtf8(m->nameIndex);
  cout << cf.getUtf8(m->descIndex);
  cout << endl;
}
\end{minted}
\caption{Traversing all methods in a class}
\label{usage-print1}
\end{listing}

Listing~\ref{usage-edit} shows how to find all constructors in a class
and how to inject instrumentation, in the form of a call to a static method
\code{static void alloc( Object o)} of an analysis class,
at the beginning of each constructor.

\begin{listing}
\begin{minted}{cpp}
ConstIndex mid = cf.addMethodRef(classIndex, 
  "alloc", "(Ljava/lang/Object;)V");

for (Method* method : cf.methods) {
  if (method->isInit()) {
    InstList& instList = method->instList();
    Inst* p = *instList.begin();
    instList.addZero(OPCODE_aload_0, p);
    instList.addInvoke(OPCODE_invokestatic, mid, p);
  }
}
\end{minted}
\caption{Instrumenting constructor entries}
\label{usage-edit}
\end{listing}

Besides providing access to all members of a class,
\texttt{ClassFile} also provides access to the constant pool
via methods like \texttt{getUtf8()} and \texttt{addMethodRef()}.

This section shows common use cases of the \jnif{} library, 
such as writing instrumentation code and analyzing class files, 
thus giving an overview of the library. 
Its components are explained in more detail in Section~\ref{sec:jnif-implementation}.
We present the examples in an incremental fashion,
adding complexity in each example.

In order to be able to work with class files, they must me parsed. 
Given a buffer with a class file and its length, Listing~\ref{usage-parse} shows how to parse it.

\begin{listing}
\begin{minted}{cpp}
const char* data = ...;
int len = ...;

jnif::ClassFile cf(data, len);
\end{minted}
\caption{Decoding a class}
\label{usage-parse}
\end{listing}

The class \code{ClassFile} represents a \java{} class file and contains the definition for each method and fields. 
The full documentation can be found online.%
\footnote{\url{https://acuarica.gitlab.io/jnif/}}

Once a class file is correctly parsed and loaded it can be manipulated using the methods and fields in \code{ClassFile}.
For instance, in order to write back the parsed class file in a new buffer, the write method is used in conjunction with the computeSize method as shown in listing~\ref{usage-write}.

\begin{listing}
\begin{minted}{cpp}
const char* data = ...;
int len = ...;
jnif::ClassFile cf(data, len);
int newlen = cf.computeSize();
u1* newdata = new u1[newlen];
cf.write(newdata, newlen);

// Use newdata and newlen

delete [] newdata;
\end{minted}
\caption{Encoding a class}
\label{usage-write}
\end{listing}

The \code{ClassFile} class has a collection of fields and methods which can be used to discover the members of the class file. 
The listing~\ref{usage-print} prints in the standard output every method's name and descriptor in a class file. 
Note that every jnif class overloads the \verb|operator<<| in order send it to an \code{std::ostream}.

\begin{listing}
\begin{minted}{cpp}
const char* data = ...;
int len = ...;
jnif::ClassFile cf(data, len);
for (jnif::Method* m : cf.methods) {
	cout << "Method: ";
	cout << cf.getUtf8(m->nameIndex);
	cout << cf.getUtf8(m->descIndex);
	cout << endl;
}
\end{minted}
\caption{Traversing all methods in a class}
\label{usage-print}
\end{listing}

To hook every invocation of a constructor, a method named <init> in Java bytecode, 
one can traverse the method list and check whether the current method is an <init> method. 
Once detected, it is possible to add instrumentation code, like for instance call a static method in a given class. 
Figure~\ref{usage-alloc} shows how to add instruction to the instruction list.

\begin{listing}
\begin{minted}{cpp}
ConstIndex mid = cf.addMethodRef(classIndex, 
  "alloc", "(Ljava/lang/Object;)V");

for (Method* method : cf.methods) {
	if (method->isInit()) {
		InstList& instList = method->instList();

		Inst* p = *instList.begin();
		instList.addZero(OPCODE_aload_0, p);
		instList.addInvoke(OPCODE_invokestatic, mid, p);
	}
}
\end{lstlisting}
\caption{Instrumenting constructor entries}
\label{usage-alloc}
\end{minipage}

Another common use case is to instrument every method entry and exit. In order to do so, one can add the instrumentation code at the beginning of the instruction list to detect the method entry. To detect method exit, it is necessary to look for instructions that terminate the current method execution, i.e., xRETURN family and ATHROW as showed in figure~\ref{usage-methodentryexit}.

\begin{listing}
\begin{minted}{cpp}
ConstIndex sid = cf.addMethodRef(proxyClass, "enterMethod",
				"(Ljava/lang/String;Ljava/lang/String;)V");
ConstIndex eid = cf.addMethodRef(proxyClass, "exitMethod",
				"(Ljava/lang/String;Ljava/lang/String;)V");
ConstIndex classNameIdx = cf.addStringFromClass(cf.thisClassIndex);

...

InstList& instList = method->instList();

ConstIndex methodIndex = cf.addString(m->nameIndex);

Inst* p = *instList.begin();

instList.addLdc(OPCODE_ldc_w, classNameIdx, p);
instList.addLdc(OPCODE_ldc_w, methodIndex, p);
instList.addInvoke(OPCODE_invokestatic, sid, p);

for (Inst* inst : instList) {
	if (inst->isExit()) {
		instList.addLdc(OPCODE_ldc_w, classNameIdx, inst);
		instList.addLdc(OPCODE_ldc_w, methodIndex, inst);
		instList.addInvoke(OPCODE_invokestatic, eid, inst);
	}
}
\end{minted}
\caption{Instrumenting <init> methods}
\label{usage-methodentryexit}
\end{listing}
