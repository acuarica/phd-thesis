\begin{pattern}{SelectOverload}
This pattern is used to select
the appropriate version of an overloaded method%
\footnote{Using ad-hoc polymorphism~\cite{stracheyFundamentalConceptsProgramming2000}}
where two or more of its implementations differ \emph{only} in some argument type.

A cast to \code{null} is often used to select against different versions
of a method, \ie{}, to resolve method overloading ambiguity.
Whenever a \code{null} value needs to be an argument of an a cast is
needed to select the appropriate implementation.
This is because the type of \code{null} has the special type \emph{null}%
\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html\#jls-4.1}}
which can be treated as any reference type.
In this case,
the compiler cannot determine which method implementation to select.

\instances{}
The following listing%\footnote{\url{http://bit.ly/2FENovD}}
shows an example of \pname{} pattern.
In this example, there are three versions of the \code{onSuccess} method,
The cast \code{(String) null} is used to select the appropriate version
(line 7), based on the third parameter.
Overloaded methods that differ only in their argument type (the third one).

Another use case is to select the appropriate the right argument when
calling a method with variable arguments.

% https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1518514025554/files/library/src/main/java/com/loopj/android/http/JsonHttpResponseHandler.java?sort=name\&dir=ASC\&mode=heatmap\&excluded=false#L150
\begin{minted}[highlightlines=1]{java}
onSuccess(statusCode, headers, (String) null);
\end{minted}

\begin{minted}{java}
public void onSuccess(
      int statusCode, Header[] headers, JSONObject response) {...}

public void onSuccess(
      int statusCode, Header[] headers, JSONArray response) {...}

public void onSuccess(
      int statusCode, Header[] headers, String responseString) {...}
\end{minted}

In the following example\footnote{\url{http://bit.ly/2FC9Llb}}
\code{actual.data()} returns \code{Long}.

% https://lgtm.com/projects/g/spullara/redis-protocol/snapshot/dist-41940059-1524814812150/files/client/src/test/java/redis/client/AllCommandsTest.java?sort=name&dir=ASC&mode=heatmap#L366
\begin{minted}[highlightlines=2]{java}
private void eq(long expected, IntegerReply actual) {
      assertEquals(expected, (long) actual.data());
}

public static void assertEquals(Object expected, Object actual) { }
public static void assertEquals(long expected, long actual) { }
\end{minted}


\footnote{\url{http://bit.ly/2HDAkbF}}

%https://lgtm.com/projects/g/groovy/groovy-core/snapshot/dist-45390050-1524814812150/files/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java?sort=name&dir=ASC&mode=heatmap#L6715
\begin{minted}[highlightlines=1]{java}
\end{minted}

\detection{}
Listing \ref{org9e0faf3} shows how to detect this pattern.
This pattern shows up when a cast is directly applied to the \texttt{null} constant.

\lstset{language=sql,label=org9e0faf3,caption={Detection of the \pname{} pattern.},captionpos=b,numbers=none,style=ql}
\begin{lstlisting}
import java

from CastExpr ce, NullLiteral nl
where ce.getExpr() = nl
select ce
\end{lstlisting}

\discussion{}
Casting the \code{null} constant seems rather artificial.
This pattern shows either a lack of expressiveness in \java{} or
a bad \api{} design.
Several other languages support default parameters, \eg{},
\scala{}, \csharp{} and \cpp{}.
Adding default parameters might be a partial solution.
% \todo{Relate null as theorical point of view in the TAPL book.}
\end{pattern}