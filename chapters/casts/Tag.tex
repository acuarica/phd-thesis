\begin{pattern}{Tag}
This pattern is used to stash an application-specific value,
typically a ``tag'' value in a GUI object or message payload.

\instances{}
In the following snippet,%
\footnote{\url{http://bit.ly/proninyaroslav_libretorrent_2TxpZCM}}
a cast is applied to a \code{getSerializable} invocation (lines 15 and 16).
This method gets a \code{Serializable} value given the specified key, \code{TAG\_CUR\_DIR} in this case.
To set a value with a specified key, the \code{putSerializable} method is used.
The mentioned cast succeeds because a value of the appropriate type is set in line 28 using the \code{putSerializable} method.

%https://lgtm.com/projects/g/proninyaroslav/libretorrent/snapshot/dist-1506096326216-1524814812150/files/app/src/main/java/org/proninyaroslav/libretorrent/fragments/DetailTorrentFilesFragment.java?sort=name&dir=ASC&mode=heatmap#L166
\begin{minted}[highlightlines=15-16]{java}
private TorrentContentFileTree curDir;

@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    if (activity == null)
        activity = (AppCompatActivity) getActivity();
    if (savedInstanceState != null) {
        files = (ArrayList<BencodeFileItem>) savedInstanceState
                                .getSerializable(TAG_FILES);
        priorities = (ArrayList<FilePriority>) savedInstanceState
                                .getSerializable(TAG_PRIORITIES);
        fileTree = (TorrentContentFileTree) savedInstanceState
                                .getSerializable(TAG_FILE_TREE);
        curDir = (TorrentContentFileTree) savedInstanceState
                                .getSerializable(TAG_CUR_DIR);
    } else {
        makeFileTree();
    }
    // [...]
}

@Override
public void onSaveInstanceState(Bundle outState) {
    outState.putSerializable(TAG_FILES, files);
    outState.putSerializable(TAG_PRIORITIES, priorities);
    outState.putSerializable(TAG_FILE_TREE, fileTree);
    outState.putSerializable(TAG_CUR_DIR, curDir);
}
\end{minted}

In the following example,%
\footnote{\url{http://bit.ly/UniTime_cpsolver_2HUmGki}}
a cast is applied to the result of looking up by index in the \code{iContexts} map (line 9).
In case there is no value for the given index,
a value of the corresponding type is stored using the same index (line 13),
thus guaranteeing the success of the cast.

%https://lgtm.com/projects/g/UniTime/cpsolver/snapshot/dist-4860376-1524814812150/files/src/org/cpsolver/ifs/assignment/context/AssignmentContextHolderMap.java?sort=name&dir=ASC&mode=heatmap#L47
\begin{minted}[highlightlines=9]{java}
protected Map<Integer,AssignmentContext> iContexts =
                new HashMap<Integer, AssignmentContext>();

@Override
@SuppressWarnings("unchecked")
public <U extends AssignmentContext> U getAssignmentContext(
                Assignment<V, T> assignment,
                AssignmentContextReference<V, T, U> reference) {
    U context = (U) iContexts.get(reference.getIndex());
    if (context != null) return context;
    
    context = reference.getParent().createAssignmentContext(assignment);
    iContexts.put(reference.getIndex(), context);
    return context;
}
\end{minted}

In the last example,%
\footnote{\url{http://bit.ly/ggp-org_ggp-base_2SAEXHu}}
the cast is applied to a \code{getModel} invocation on the \code{matchTable} field (line 16).
Looking how \code{matchTable} is initialized (line 7),
the \code{model} variable (line 5) is used as an argument to the constructor.
This argument is the value returned by \code{getModel},
and since they are both of the same type,
the mentioned cast is guaranteed to succeed.

%https://lgtm.com/projects/g/ggp-org/ggp-base/snapshot/dist-59800051-1524814812150/files/src/main/java/org/ggp/base/apps/player/match/MatchPanel.java?sort=name&dir=ASC&mode=heatmap#L66
\begin{minted}[highlightlines=16]{java}
public final class MatchPanel extends JPanel implements Observer {
    private final JZebraTable matchTable;
    public MatchPanel() {
        super(new GridBagLayout());
        DefaultTableModel model = new DefaultTableModel();
        // [...]
        matchTable = new JZebraTable(model) {
            @Override
            public boolean isCellEditable(int rowIndex, int colIndex) {
                return false;
            }
        };
    }
    // [...]
    private void observe(GamerCompletedMatchEvent event) {
        DefaultTableModel model = (DefaultTableModel) matchTable.getModel();
        model.setValueAt("Inactive", model.getRowCount() - 1, 4);
    }
}
\end{minted}


\detection{}
This pattern consists of a cast on a third-party library method,
that retrieves a value previously set.
The characteristic feature is that the method returns a more general type,
hence a cast is needed.

\discussion{}
Usually, the client application knows at compile-time the kind of values that the \thisp{} will use.

\related{}
This pattern is closely related to the \nameref{pat:LookupById} pattern.
The \thisp{} pattern can also be used to fetch a value from a collection (as in \nameref{pat:LookupById}).
The main difference is ``locality''.
That is, in the \thisp{} pattern the cast value is set ``locally'', \ie,
in the same method or class,
whereas the cast value in the \nameref{pat:LookupById} pattern is usually set in another class.

The \nameref{pat:VariableLessSpecificType} pattern resembles this pattern,
since a value is stashed using a less specific type.

\end{pattern}