\begin{pattern}{VariableLessSpecificType}
This pattern occurs when a cast is applied to a variable (local variable,
parameter, or field),
that is usually being assigned once and
is declared with a less specific type than the type of the value 
that is being assigned to.
The type of the value being assigned to can be determined locally
either within the enclosing method or class.

\instances{}
%
The following snippet%
\footnote{\url{http://bit.ly/apache_cxf_2SNoUXj}}
shows an example of the \thisp{} pattern.
The variable \code{samlTokenRenewer} is being casted to the \code{SAMLTokenRenewer} class (line 4).
The variable is declared with type \code{TokenRenewer} (superclass of \code{SAMLTokenRenewer}) in line 1.
However, the variable is being initialized with the expression \code{new SAMLTokenRenewer()}. 
Thus, the cast instance could be trivially avoided by changing the declaration of the \code{samlTokenRenewer} variable to \code{SAMLTokenRenewer} instead of \code{TokenRenewer}.

%https://lgtm.com/projects/g/apache/cxf/snapshot/dist-2126650689-1524814812150/files/services/sts/sts-core/src/test/java/org/apache/cxf/sts/token/renewer/SAMLTokenRenewerTest.java?sort=name&dir=ASC&mode=heatmap#L465
\begin{minted}[highlightlines=4]{java}
TokenRenewer samlTokenRenewer = new SAMLTokenRenewer();
samlTokenRenewer.setVerifyProofOfPossession(false);
samlTokenRenewer.setAllowRenewalAfterExpiry(true);
((SAMLTokenRenewer)samlTokenRenewer).setMaxExpiry(1L);
\end{minted}


The following example%
\footnote{\url{http://bit.ly/facebookarchive_hadoop-20_2FuDeO7}}
shows the \thisp{} pattern.
We can see that the field \code{uncompressedDirectBuf} is being casted to the \code{java.nio.ByteBuffer} class (line $13$) but it is declared as \code{java.nio.Buffer} (line $3$).
Nevertheless, the field is assigned only once in the constructor (line $7$)
with a value of type \code{java.nio.ByteBuffer}.
The value assigned is returned by the method
\code{ByteBuffer.allocateDirect}.%
\footnote{\url{https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html\#allocateDirect(int)}}
Inspecting the enclosing class, there is no other assignment to the
\code{uncompressedDirectBuf} field,
thus making possible to declare it as \code{final}.
Therefore, the cast pattern in line $13$ will always succeed.
Any other similar use of the \code{uncompressedDirectBuf} field needs to be casted to as well.

% https://lgtm.com/projects/g/facebookarchive/hadoop-20/snapshot/dist-1802091768-1524814812150/files/src/core/org/apache/hadoop/io/compress/snappy/SnappyCompressor.java?sort=name&dir=ASC&mode=heatmap#L134
\begin{minted}[highlightlines=13]{java}
public class SnappyCompressor implements Compressor {
    // [...]
    private Buffer uncompressedDirectBuf = null;
    // [...]
    public SnappyCompressor(int directBufferSize) {
        // [...]
        uncompressedDirectBuf = ByteBuffer.allocateDirect(directBufferSize);
        // [...]
    }
    // [...]
    synchronized void setInputFromSavedData() {
        // [...]
        ((ByteBuffer) uncompressedDirectBuf).put(userBuf, userBufOff,
            uncompressedDirectBufLen);
        // [...]
    }
    // [...]
}
\end{minted}

\footnote{\url{http://bit.ly/oblac_jodd_2UKxm6H}}

%https://lgtm.com/projects/g/oblac/jodd/snapshot/dist-12050004-1524814812150/files/jodd-core/src/main/java/jodd/util/collection/SortedArrayList.java?sort=name&dir=ASC&mode=heatmap#L154
\begin{minted}[highlightlines=7]{java}
public class SortedArrayList<E> extends ArrayList<E> {
    protected final Comparator<E> comparator;
    // [...]
    @SuppressWarnings( {"unchecked"})
    protected int compare(final E k1, final E k2) {
            if (comparator == null) {
                    return ((Comparable) k1).compareTo(k2);
            }
            return comparator.compare(k1, k2);
    }
}
\end{minted}

\detection{}
To detect this pattern, a cast needs to be applied to a variable whose
value can be determined simply by looking at
the enclosing method or class.

\discussion{}
In most the cases this can be considered as a bad practice or
code smell.
This is because by only changing the declaration of the variable
to a more specific type type, the cast can be simply eliminated.

\related{}
This pattern is related to the \nameref{pat:Redundant} pattern.
Although \thisp{} is not redundant,
by only changing the declaration of the variable to a more specific type,
the cast becomes redundant.

\end{pattern}