\section{Issues Developers have Applying the Cast Operator}

\emph{But do cast operations pose a problem for developers?}
Several studies~\citep{kechagiaUndocumentedUncheckedExceptions2014,coelhoUnveilingExceptionHandling2015,zhitnitskyTop10Exception2016}
suggest that in \java{},
%
\done{Nate: Expand on this}
%
the \code{ClassCastException} is in the top 10 of exceptions being thrown when analysing stack traces.
These studies have analyzed the exceptions thrown in stack traces.
The exceptions come from third-party libraries \api{}s and the Android \api{},
indicating a misuse of such \api{}s.
The \code{ClassCastException} is in the top 10 of exceptions thrown,
thus it represents a problem for developers.

To illustrate the sort of problems developers have when applying casting conversions,
%
\done{Nate: Why GitHub?}
%
we performed a simple search for commits and issues including the term \code{ClassCastException} within projects marked as using the \java{} language on \github{}.
We have used \github{} since is the largest host of source code in the world~\citep{gousiosLeanGHTorrentGitHub2014}.
The searches returned about 171K commits%
\footnote{\url{https://github.com/search?l=Java&q=ClassCastException&type=Commits}}
and 73K issues%
\footnote{\url{https://github.com/search?l=Java&q=ClassCastException&type=Issues}}
%
\todo{Nate: Unclear}
\todo{Nate: Need short background section at beginning. What is a cast? upcast, downcast, instanceof? How compiled? checkcast.}
%
results respectively at the time of this writing.
At first glance, these results indicate that \code{ClassCastException} indeed represents a source for problems to developers.

We have included here a few commit results as an example of issues developers have when using the cast operator.
To easily spot what the developer has changed to fix the \code{ClassCastException} being thrown,
we present each source code excerpt using the Git commit \emph{diff} as reported by \github{}.

\textbf{Forgotten Guard.}
The following diff%
\footnote{\url{https://github.com/jenkinsci/extra-columns-plugin/commit/02d10bd1fcbb2e656da9b1b4ec54208b0cc1cbb2}}
shows a cast applied to the variable \code{job} (in line 6) that throws \code{ClassCastException} because the developer forgot to include a guard.
In this case, the developer fixed the error by introducing an \code{instanceof} guard to the cast.

\begin{lstlisting}[style=java]
@@ -41,6 +41,8 @@ public SCMTypeColumn() {
   }
       public String getScmType(@SuppressWarnings("rawtypes") Job job) {
+        if(!(job instanceof AbstractProject<?, ?>))
+            return "";
       AbstractProject<?, ?> project = (AbstractProject<?, ?>) job;
       return project.getScm().getDescriptor().getDisplayName();
   }
\end{lstlisting}

\textbf{Wrong Cast Target.}
In the next example%
\footnote{\url{https://github.com/GoldenGnu/jeveassets/commit/5f4750bc8cfa7eed8ad01efd8add2cd2cc9bd831}}
%
\done{Nate: use the wrong class name}
%
the developer made a mistake by choosing a wrong class for the cast target,
\ie, \code{JCustomFileChooser} instead of \code{CustomFileFilter}.
The \code{CustomFileFilter} is an inner static class inside the \code{JCustomFileFilter} class.
There is no subclass relationship between these two classes.
The cast happens inside an \code{equals} method
--- where this idiom is well known ---
within the \code{CustomFileFilter} class.
But the developer made a typo, using the outer class (\code{JCustomFileFilter}), instead of the inner class (\code{CustomFileFilter}).

\begin{lstlisting}[style=java]
@@ -156,7 +156,7 @@ public boolean equals(Object obj) {
  if (getClass() != obj.getClass()) {
      return false;
  }
- final JCustomFileChooser other = (JCustomFileChooser) obj;
+ final CustomFileFilter other = (CustomFileFilter) obj;
  if (!Objects.equals(this.extensions, other.extensions)) {
      return false;
  }
\end{lstlisting}

\textbf{Generic Type Inference Mismatch.}
In the following listing,%
\footnote{\url{https://github.com/ethereum/ethereumj/commit/224e65b9b4ddcb46198a6f8faf69edc65d34d382}}
the \emph{dynamic} property \code{"peer.p2p.pingInterval"} (lines 5 and 6) has type \code{int}.
To fix the error, the developer changed only the type of the
literal 5: from \code{long} to \code{int}.

\begin{lstlisting}[style=java]
@@ -281,7 +281,7 @@ private void startTimers() {
        } catch (Throwable t) {
            logger.error("Unhandled exception", t);
        }
-   }, 2, config.getProperty("peer.p2p.pingInterval", 5L), TimeUnit.SECONDS);
+   }, 2, config.getProperty("peer.p2p.pingInterval", 5), TimeUnit.SECONDS);
}
\end{lstlisting}

Looking at the definition of the \code{getProperty} method below,%
\footnote{\url{https://github.com/ethereum/ethereumj/blob/224e65b9b4ddcb46198a6f8faf69edc65d34d382/ethereumj-core/src/main/java/org/ethereum/config/SystemProperties.java\#L312}}
it obtains a dynamic property given a property name.
If it finds a value, it returns it.
Otherwise, it returns the default value (the second argument).
\done{Nate: Show earlier}

\begin{lstlisting}[style=java]
public <T> T getProperty(String propName, T defaultValue) {
    if (!config.hasPath(propName)) return defaultValue;
    String string = config.getString(propName);
    if (string.trim().isEmpty()) return defaultValue;
    return (T) config.getAnyRef(propName);
}
\end{lstlisting}

But the return type of \code{getProperty} is a generic type inferred
by the type of the default value, in this case, \code{long}.
Since the default value is a generic parameter, the type \code{long} is wrapped into \code{java.lang.Long} due to autoboxing.
The \code{ClassCastException} is then thrown in line $5$,
when casting \code{java.lang.Integer} to \code{java.lang.Long}.
To then fix the bug, the developer changed the type of the literal
from \code{long} to \code{int}.


\textbf{Compiler Bug.}
One issue%
\footnote{\url{https://github.com/mockito/mockito/issues/357}}
%
\todo{Nate: vague}
%
shows bad things happen when abusing the type system.
A bug in the \textsf{javac} compiler%
\footnote{\url{https://bugs.openjdk.java.net/browse/JDK-8058199}}
caused \jvm{}'s \code{checkcast} instructions to be skipped.
This bug was fixed in JDK 9,
%
\todo{?}
%
breaking Mockito answer strategies.
