\section{Finding Casts Usage Patterns}
\label{sec:casts:methodology}

Similarly to Section~\ref{sec:casts:stats}, to answer both research questions
\ref{casts:rq2} (\emph{\crqB}) and \ref{casts:rq3} (\emph{\crqC}) several elements are needed.

\textbf{Source Code Analysis.}
Given the complexity of meaningfully categorizing cast usages into patterns,
we have opted to manually analyze code snippets to devise cast usage patterns.
We used the \ql{} query language within the \lgtm{} service to fetch all cast operator instances.

\textbf{Projects.}
As for the project selection, we have used the Semmle project database.
We argue this database provides a close approximation to ``real world'' applications, since teams that want their code to be analyzed push their projects onto \href{https://lgtm.com}{lgtm.com} to run queries against them.
This filters out uninteresting projects, \eg, student projects.
There are also popular projects, \eg,
Apache Maven,\footnote{\url{https://lgtm.com/projects/g/apache/maven}}
Neo4j,\footnote{\url{https://lgtm.com/projects/g/neo4j/neo4j/}}
Hibernate,\footnote{\url{https://lgtm.com/projects/g/hibernate/hibernate-orm/}}
that were pulled in by Semmle itself as demo projects.

% For each cast, I have the path within the project.
% But to manually analyze them, I need to get the lgtm.com link.
% This is necessary to actually see the code snippet in which the cast appear.

At the time of writing, there is a total of 7.559 projects in the Semmle project database, with a total 10,193,435 casts.
There are 215 projects for which we could not get the source code to be analyzed.
In total, these 215 projects represents 1,162,583 casts.
Moreover, there are also 516 projects that does not contain any cast.
Therefore the total cast population to be analyzed consists of 9,030,852 casts spread in 6,840 projects.

We assume that all cast instances can be categorized in several patterns.
Since the amount of cast instances is quite large, it is not feasible to \emph{manually} analyze all of them.
Therefore we have opted to perform random sampling to get a subset of cast instances to manually analyze.
Now comes the question: \emph{What is an appropriate sample size?}
We want to pick a sample size such that the probability of missing the least frequent pattern is extremely low.
This kind of question is exactly answered by the \textbf{Hypergeometric Distribution}.

The Hypergeometric Distribution is a discrete probability distribution used with a finite population of size $N$ of subjects with two distinct features.
It is used to calculate the probability of obtaining $k$ successes of getting one feature --- provided that there are $K$ subjects with that feature in the population --- in $n$ draws.

Returning to our problem of finding an appropriate sample size, we can model our question as follows:
The two distinct features are either finding a cast of the least frequent pattern or not.
Therefore we want to know what is the probability of not finding this pattern, \ie, $k = 0$.
Our finite population consists of $N = 9,030,852$ cast instances.
Then we assume that a pattern is irrelevant if it represents less than $0.1\%$ of the population, thus $K = 9,000$ cast instances.
Plugging-in these parameters using the Hypergeometric Distribution formula,%
\footnote{The reader can use any available online Hypergeometric Distribution calculator to plug-in these parameters, \eg, \url{https://keisan.casio.com/exec/system/1180573201}}
with different sample sizes, we found that with a sample size of $n = 5000$ the probability is $0.0068$, \ie, less than $0.1 \%$, of not finding the least frequent pattern.

% \subsection*{Why do we not use \ql{} to find cast patterns?}

% After all cast instances are found, we analyze this information to discover usage patterns.
% \ql{} allows us to automatically categorize cast use cases into patterns.

% Our list of patterns is not exhaustive.
% Due to the nature of the cast operator, some casts were uncategorized as they would need a whole program analysis, \eg{}, including libraries in the analysis.

% As mentioned in section \ref{sec:casts:stats}, \ql{} treats primitive conversions as casts.
% Thus, a preliminary step is to exclude them as cast instances.
% The following \ql{} query shows how to retrieve all relevant cast expressions:

% We have used this initial result as a starting point for our analysis.
% Afterwards, we select a random sample for manual inspection.
% We manually inspected the mentioned casts trying to understand why and how they were used.

% Our first approach was to use to find cast usage patterns was to use \ql{}.
% Some code patterns might be too difficult to express in terms of \ql{} queries.
% This situation arises when the knowledge to determine the pattern is outside the source code, \eg, in configuration files or library call sites.
% Thus, in those cases we can only acknowledge that a pattern exists, but not how recurrent it is.
