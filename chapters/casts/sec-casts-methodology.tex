\section{Finding Casts Usage Patterns}
\label{sec:casts:methodology}

Similarly to \S\ref{sec:casts:stats}, to answer both research questions
\ref{casts:rq2} (\emph{\crqB}) and \ref{casts:rq3} (\emph{\crqC}) several elements are needed.

\textbf{Source Code Analysis.}
Given the complexity of finding cast usage patterns, we have opted to use manual sampling to devise cast usage patterns.
We have used the \ql{} query language within the \lgtm{} service to fetch all cast operator instances.

\textbf{Projects.}
As for the project selection, we have used the Semmle project database.
We can argue that this provide a good filter of projects,
since teams that want their code to be analyzed push their projects onto \href{https://lgtm.com}{lgtm.com}.
This will filter out for instance student projects from github.
There are also popular projects, e.g., gradle, neo4j, google guava,
that probably were pulled in by Semmle.
We need to double check with them, but if that’s the case,
we can make a good argument as for the project selection.

At the time of writing, there is a total of 7.559 projects, with a total 10,193,435 casts.
For each cast, I have the path within the project.
But to manually analyze them, I need to get the lgtm.com link.
This is necessary to actually see the code snippet in which the cast appear.
There are 215 projects for which I can’t get the lgtm.com link.
These 215 projects contains 1,162,583 casts.
There are also 516 projects which does not contain any cast.
Therefore the cast population from where make the sampling consists of
9,030,852 casts spread in 6,840 projects.

Now comes the question: What is an appropriate sample size?
Using this online calculator:

Hypergeometric distribution
We have used an online calculator to compute our sample size.%
\footnote{\url{https://keisan.casio.com/exec/system/1180573201}}


% \subsection*{Why do we not use \ql{} to find cast patterns?}

% After all cast instances are found, we analyze this information to discover usage patterns.
% \ql{} allows us to automatically categorize cast use cases into patterns.

% Our list of patterns is not exhaustive.
% Due to the nature of the cast operator, some casts were uncategorized as they would need a whole program analysis, \eg{}, including libraries in the analysis.

% As mentioned in section \ref{sec:casts:stats}, \ql{} treats primitive conversions as casts.
% Thus, a preliminary step is to exclude them as cast instances.
% The following \ql{} query shows how to retrieve all relevant cast expressions:

% We have used this initial result as a starting point for our analysis.
% Afterwards, we select a random sample for manual inspection.
% We manually inspected the mentioned casts trying to understand why and how they were used.

% Our first approach was to use to find cast usage patterns was to use \ql{}.
% Some code patterns might be too difficult to express in terms of \ql{} queries.
% This situation arises when the knowledge to determine the pattern is outside the source code, \eg, in configuration files or library call sites.
% Thus, in those cases we can only acknowledge that a pattern exists, but not how recurrent it is.
