\section{Finding Cast Usage Patterns}
\label{sec:casts:methodology}

To answer our research questions,
\ref{casts:rq2} (\emph{\crqB}) and \ref{casts:rq3} (\emph{\crqC}) several elements are needed,
we need a corpus of representative ``real world'' code and we need to perform
source code analysis to identify cast operations and to help classify these
operations.

\subsection{Corpus Analysis}

We gathered cast usage data using the \ql{} query language,
``a declarative, object-oriented logic programming language for querying
complex, potentially recursive data structures encoded in a relational data
model''~\citep{avgustinovQLObjectorientedQueries2016}.
\ql{} allows us to analyze programs at the source code level.
\ql{} extracts the source code of a project into a Datalog model.
Besides providing structural data for programs, \ie{}, ASTs,
\ql{} has the ability to query static types and perform data-flow analysis.
To run our \ql{} queries,
we have used the \lgtm{} service provided by Semmle,%
\footnote{\url{https://lgtm.com/}}
the developers of \ql{}.

The \lgtm{} project database includes---at the time of writing---7,559 \java{} projects imported from
open-source projects hosted in \github{}.
The \lgtm{} database was constructed by importing popular open-source projects, \eg,
Apache Maven,\footnote{\url{https://lgtm.com/projects/g/apache/maven}}
Neo4j,\footnote{\url{https://lgtm.com/projects/g/neo4j/neo4j/}},
and Hibernate\footnote{\url{https://lgtm.com/projects/g/hibernate/hibernate-orm/}}.
Additionlly it includes projects exported by developers
to \lgtm{} to query them for bug finding, smell detection, and
other analyses.
We argue that this project selection provides a wide coverage over realistic
\java{} applications, excluding
uninteresting projects, \eg, student projects.

\subsection{Methodology}

To identify patterns of cast usage, we analyzed all \java{} projects in the \lgtm{} database, 7,559 projects
with a total 10,193,435 casts, at the time of writing.
There are 215 projects in the database for which we could not retrieve the source code.
In total, these 215 projects contain 1,162,583 casts.
Moreover, there are also 516 projects that do not contain any cast.
Therefore the total cast population to be analyzed consists of 9,030,852 casts in 6,840 projects.

Because the number of cast instances is large, it is not feasible to \emph{manually} analyze all of them.
Therefore we have opted to perform random sampling to get a subset of cast instances to analyze.
To choose a sample size such that the
the probability of missing the least frequent pattern is extremely low, we assume a
hypergeometric distribution of the data.
The hypergeometric distribution is a discrete probability distribution used with a finite population of $N$ subjects.
It is used to calculate the probability of drawing $k$ subjects with a given feature---provided that there are $K$ subjects with that feature in the population---in $n$ draws, without replacement.

Returning to our problem of finding an appropriate sample size, we model our question as follows:
We assume there are $K$ casts that are members of the least frequently occurring pattern.
We want to know the probability of not finding this pattern, \ie, sampling exactly $k = 0$.
Our population consists of $N = 9,030,852$ cast instances.
For our study, we assume that a pattern is irrelevant if it represents less than $0.1\%$ of the population, or $K = 9,031$ cast instances.
Plugging-in these parameters using the hypergeometric distribution formula,%
\footnote{The reader can use any hypergeometric distribution calculator, \eg, \url{https://keisan.casio.com/exec/system/1180573201}}
we found that with a sample size of $n = 5,000$ the probability of not sampling the
least frequently occurring pattern is $0.67\%$.

%
The manual categorization file can be found online.% 
\footnote{\url{https://gitlab.com/acuarica/phd-thesis/blob/master/analysis/casts-5000.csv}}
This file is comma-separated values (CSV) table.
Each row represents a cast instance.
The last two columns in this table are the link to the source code snippet and the result of the manual inspection.
The script to process the results of the manual inspection is available online.%
\footnote{\url{https://gitlab.com/acuarica/phd-thesis/blob/master/analysis/analysis.r}}


% \subsection*{Why do we not use \ql{} to find cast patterns?}

% After all cast instances are found, we analyze this information to discover usage patterns.
% \ql{} allows us to automatically categorize cast use cases into patterns.

% Our list of patterns is not exhaustive.
% Due to the nature of the cast operator, some casts were uncategorized as they would need a whole program analysis, \eg{}, including libraries in the analysis.

% As mentioned in section \ref{sec:casts:stats}, \ql{} treats primitive conversions as casts.
% Thus, a preliminary step is to exclude them as cast instances.
% The following \ql{} query shows how to retrieve all relevant cast expressions:

% We have used this initial result as a starting point for our analysis.
% Afterwards, we select a random sample for manual inspection.
% We manually inspected the mentioned casts trying to understand why and how they were used.

% Our first approach was to use to find cast usage patterns was to use \ql{}.
% Some code patterns might be too difficult to express in terms of \ql{} queries.
% This situation arises when the knowledge to determine the pattern is outside the source code, \eg, in configuration files or library call sites.
% Thus, in those cases we can only acknowledge that a pattern exists, but not how recurrent it is.
