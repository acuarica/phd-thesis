\section{Discussion}\label{sec:casts:discussion}

\newcommand{\gc}[1]{\emph{\textbf{#1}}}
\newcommand{\gh}[1]{\item\gc{#1}}
There are common aspects shared by several patterns.
Table~\ref{table:casts:categories} presents a summary of the patterns and their different aspects.
The table consists of the following columns:
\begin{itemize}
\gh{Pattern} Indicates the name of the pattern.
\gh{Guarded} The patterns here are guarded casts.
A guarded cast is a cast such that before the cast is applied,
some condition---the \emph{guard}---needs to be verified.
The condition to be verified guarantees that the cast will not fail at runtime (unless there is a bug in the application), \ie,
the cast will not throw a \code{ClassCastException}.
Some kind of guards ensure that the cast will not fail at the language-level,
while others only can guarantee it at the application-level.
\gh{Language} These casts could be ameliorated if there is enough language support by changing the type system.
\gh{Tools} The casts in this group could be checked with new analysis or compiler tools.
\gh{Auto} These casts are related to generated or boilerplate code.
\gh{Refactor} The casts with this aspect can be simply removed by the developer,
can be removed with little refactoring,
or suggest a code smell in the source code.
\gh{Generics} The casts in this category are related to generics or reified generics.
\gh{Boxing} These casts are related with explicit boxing/unboxing operations, \ie{},
explicit converting values of primitive types to boxed types and vice versa.
\gh{\ql{}}
A half sign (\sfrac{1}{2}) in this column indicates that a pattern is partially detected in \ql{},
a check mark (\tick{}) indicates that we have provided a \ql{} query for automatic detection, and
an empty cell indicates that is infeasible or impractical to detect this pattern in \ql{}.
\end{itemize}

\input{chapters/casts/table-casts-categories}

Many programming languages provide features to ameliorate the more common use cases of casts.
For instance,
\kotlin{}'s smart casts couple together the \code{instanceof} operator and cast operation on value, 
providing direct support for the \nameref{pat:Typecase} and \nameref{pat:Equals} patterns.
More generally, ML-style pattern matching subsumes this pattern.
Smart casts do not apply directly to the \nameref{pat:OperandStack} pattern,
since it is dispatched depending on some application-specific control state.

Other language features that might at least partially obviate the need for some of the patterns are
intersection types (\cf{} \nameref{pat:ImplicitIntersectionType}),
and self types or associated types (\cf{} 
\nameref{pat:Factory},
\nameref{pat:KnownReturnType},
\nameref{pat:Deserialization},
\nameref{pat:CovariantReturnType},
\nameref{pat:FluentAPI}).
Virtual classes~\citep{gbeta, scalaIndependentlyExtensible} and languages that support family polymorphism~\citep{ernstFamilyPolymorphism2001}
would help with casts in the \nameref{pat:Family} pattern.

Some cast can be automatically generated.
The \variant{StaticResource} variant in \nameref{pat:Stash} could be generated by a GUI editor,
given that it is most seen in Android applications.
The \nameref{pat:Equals} pattern is composed of boilerplate code.
For instance, \scala{}' solves this issue by introducing \emph{case classes},
which among other features, provide equality out of the box.

Patterns like \nameref{pat:Factory} are prevalent in test code,
because when testing the developer calls the factory methods with known-parameters.
The \variant{StaticResource} appear only in source code.
This could be because of our sample does not contain any code generation for Android,
\eg{}, Butter Knife.
\nameref{pat:UseRawType} is prevalent in generated code.
In those cases, code generators do not make the effort to avoid these casts.
In our sample, the \nameref{pat:AccessSuperclassField} pattern only appears in generated code.
However, we found other instances using \ql{}.

Our study also suggests analyses could be performed to improve code quality and eliminate some cast usages,
for instance finding opportunities to use generics instead (\cf{} \nameref{pat:UseRawType}),
removing redundant casts (\cf{} \nameref{pat:Redundant}),
or locating and removing code smells (\cf{}
\nameref{pat:KnownReturnType},
\nameref{pat:VariableSupertype}, and
\nameref{pat:ObjectAsArray}).

The
\nameref{pat:RemoveWildcard},
\nameref{pat:GenericArray} and
\nameref{pat:CovariantGeneric}
patterns are used to workaround the erasure of generic type parameters in \java{};
while the \nameref{pat:UnoccupiedTypeParameter} pattern is used to take advantage of it.
Reified generics or definition-site, rather than use-site,
variance annotations~\citep{altidorTamingWildcardsCombining2011}
would reduce the need for these patterns.
There is an ongoing proposal%
\footnote{\url{https://openjdk.java.net/jeps/300}}~\citep{jep300}
to enhance \java{} with this feature.

The
\nameref{pat:UseRawType},
\nameref{pat:CovariantGeneric}, and
\nameref{pat:GenericArray}
patterns use either boxing or unboxing because of the interplay between primitive types and generics.
The JEP 218 Generics over Primitive Types%
\footnote{\url{https://openjdk.java.net/jeps/218}}~\citep{jep218}
could ameliorate the situation in this respect.
On the other hand, 
the \nameref{pat:SelectOverload} pattern uses boxing/unboxing to select the appropriate method,
while the \nameref{pat:ReflectiveAccessibility} pattern
uses unboxing when the field being accessed is of a primitive type.

The \gc{\ql{}} column shows whether a pattern can be automatically detected using \ql{}.
Currently we have \nCmarkCount{} patterns for which we can automatically detect them, and
\nExisCount{} where at least we can partially detect them.
Just \nXmarkCount{} patterns (out of \nPattern{} or \nXmarkPerc{}\%) are impractical to automatically detect.

To detect patterns like
\nameref{pat:Typecase},
\nameref{pat:Equals}, and
\nameref{pat:Redundant},
only a local analysis (within a method) is needed.
Some generic related patterns, \eg{},
\nameref{pat:UseRawType},
\nameref{pat:RemoveWildcard}, and
\nameref{pat:GenericArray},
are local.
On the other hand,
patterns like \nameref{pat:VariableSupertype} and
\nameref{pat:UnoccupiedTypeParameter} require a non-local analysis.
However, the \nameref{pat:VariableSupertype} pattern can be detected when
is instantiated locally, \ie{},
the cast and the variable assignment are in the same method.
Generic related patterns like \nameref{pat:FluentAPI} and \nameref{pat:CovariantGeneric} require a non-local analysis as well.

There are patterns that depend exclusively on known methods, \eg{},
\nameref{pat:NewDynamicInstance}, and
\nameref{pat:ReflectiveAccessibility}.
These patterns are easily detectable.
Although a pattern like \nameref{pat:Deserialization} depends on a well-known method---\code{readObject}---an application could use others deserialization mechanisms.

Some other patterns are inherently complex to detect, \eg{},
\nameref{pat:Stash},
\nameref{pat:Family},
\nameref{pat:OperandStack}, and
\nameref{pat:Composite}.
Recognition of these patterns would require to take into account many different variants,
which makes automatic detection impractical.
Manually inspection would be better suited in these cases. 

Detection of patterns like \nameref{pat:Factory} and \nameref{pat:KnownReturnType} requires to look-up method definitions,
often define in external dependencies.
At the time of this writing, \ql{} does not permit to analyse external dependencies.
