\section{Discussion}\label{sec:casts:discussion}

\input{chapters/casts/table-casts-categories}

\newcommand{\gh}[1]{\emph{\textbf{#1}}}

There are common aspects shared by several patterns.
Table~\ref{table:casts:categories} presents a summary of the patterns and their different aspects.
The table consists of the following columns:
The \gh{Pattern} column indicates the name of the pattern.
\gh{Guarded} The patterns here are guarded casts.
A guarded cast is a cast such that before the cast is applied,
some condition---the \emph{guard}---needs to be verified.
The condition to be verified guarantees that the cast will not fail at runtime (unless there is a bug in the application), \ie,
the cast will not throw a \code{ClassCastException}.
Some kind of guards ensure that the cast will not fail at the language-level,
while others only can guarantee it at the application-level.
\gh{Lang} These casts could be ameliorated if there is enough language support by changing the type system.
\gh{Tools} The casts in this group could be checked with new analysis or compiler tools.
\gh{Auto} These casts are related to generated or boilerplate code.
\gh{Refactor} The casts with this aspect can be simply removed by the developer,
can be removed with little refactoring,
or suggest a code smell in the source code.
\gh{Generics} The casts in this category are related to generics or reified generics.
\gh{Boxing} These casts are related with explicit boxing/unboxing operations, \ie{},
explicit converting values of primitive types to boxed types back and forth.
\gh{\ql{}}
A bullet (\exis{}) in the \ql{} columns indicates that a pattern is partially detected in \ql{};
a check mark (\tick{}) indicates that we have provided a \ql{} query for automatic detection; and
a cross mark (\xmark{}) indicates that is unfeasible or impractical to detect this pattern in \ql{}.

Many programming languages provide features to ameliorate the more common use cases of casts.
For instance,
\kotlin{}'s smart casts couple together the \code{instanceof} operator and cast operation on value, 
providing direct support for the \nameref{pat:Typecase} and \nameref{pat:Equals} patterns.
More generally, ML-style pattern matching subsumes this pattern.
Smart casts do not apply directly to the \nameref{pat:OperandStack} pattern,
since it is dispatched depending on some application-specific control state.

Other language features that might at least partially obviate the need for some of the patterns are
intersection types (\cf{} \nameref{pat:ImplicitIntersectionType}),
and self types or associated types (\cf{} 
\nameref{pat:Factory},
\nameref{pat:KnownReturnType},
\nameref{pat:Deserialization},
\nameref{pat:CovariantReturnType},
\nameref{pat:FluentAPI}).
Virtual classes~\citep{gbeta, scalaIndependentlyExtensible} and languages that support family polymorphism~\citep{ernstFamilyPolymorphism2001}
would help with casts in the \nameref{pat:Family} pattern.

Some cast can be automatically generated.
The \variant{StaticResource} variant in \nameref{pat:Stash} could be generated by a GUI editor,
given that it is most seen in Android applications.
The \nameref{pat:Equals} pattern is composed of boilerplate code.
For instance, \scala{}' solves this issue by introducing \emph{case classes},
which among other features, provide equality out of the box.

Our study also suggests analyses could be performed to improve code quality and eliminate some cast usages,
for instance finding opportunities to use generics instead (\cf{} \nameref{pat:UseRawType}),
removing redundant casts (\cf{} \nameref{pat:Redundant}),
or locating and removing code smells (\cf{}
\nameref{pat:KnownReturnType},
\nameref{pat:VariableSupertype}, and
\nameref{pat:ObjectAsArray}).

The
\nameref{pat:RemoveWildcard},
\nameref{pat:GenericArray} and
\nameref{pat:CovariantGeneric}
patterns are used to workaround the erasure of generic type parameters in \java{};
while the \nameref{pat:UnoccupiedTypeParameter} pattern is used to take advantage of it.
Reified generics or definition-site, rather than use-site,
variance annotations~\citep{altidorTamingWildcardsCombining2011}
would reduce the need for these patterns.
There is an ongoing proposal%
\footnote{\url{https://openjdk.java.net/jeps/300}}~\citep{jep300}
to enhance \java{} with this feature.

The
\nameref{pat:UseRawType},
\nameref{pat:CovariantGeneric}, and
\nameref{pat:GenericArray}
patterns use boxing/unboxing because of the interplay between primitive types and generics.
The JEP 218 Generics over Primitive Types%
\footnote{\url{https://openjdk.java.net/jeps/218}}~\citep{jep218}
could ameliorate the situation in this aspect.
On the other hand, 
the \nameref{pat:SelectOverload} pattern uses boxing/unboxing to select the appropriate method,
while the \nameref{pat:ReflectiveAccessibility} pattern
uses unboxing when the field being accessed is of a primitive type.

To detect patterns like
\nameref{pat:Typecase},
\nameref{pat:Equals}, and
\nameref{pat:Redundant},
only a local analysis (within a method) is needed.
Usually generic related patterns, \eg{},
\nameref{pat:UseRawType},
\nameref{pat:RemoveWildcard},


On the other hand,
patterns like \nameref{pat:VariableSupertype} and
\nameref{pat:UnoccupiedTypeParameter} require a global analysis.

There are patterns that depend exclusively on known methods, \eg{},
\nameref{pat:NewDynamicInstance}, and
\nameref{pat:ReflectiveAccessibility}.
These patterns are easily detectable.
Although a pattern like \nameref{pat:Deserialization} depends on a well-known method---\code{readObject}---an application could use others deserialization mechanisms.

Some other patterns are inherently complex to detect, \eg{},
\nameref{pat:Stash},
\nameref{pat:Family},
\nameref{pat:OperandStack}, and
\nameref{pat:Composite}.
Recognition of these patterns would require to take into account many different variants,
which makes automatic detection impractical.
Manually inspection would be better suited in these cases. 

Patterns like \nameref{pat:Factory} and \nameref{pat:KnownReturnType}

