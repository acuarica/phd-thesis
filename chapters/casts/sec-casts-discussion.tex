\section{Discussion}\label{sec:casts:discussion}

\input{chapters/casts/table-casts-categories}

\newcommand{\gh}[1]{\emph{\textbf{#1}}}

There are common aspects shared by several patterns.
Table~\ref{table:casts:categories} presents a summary of the patterns and their different aspects.
The table consists of the following columns:
The \gh{Pattern} column indicates the name of the pattern.
\gh{Guarded?} The patterns here are guarded casts.
A guarded cast is a cast such that before the cast is applied,
some condition---the \emph{guard}---needs to be verified.
The condition to be verified guarantees that the cast will not fail at runtime (unless there is a bug in the application), \ie,
the cast will not throw a \code{ClassCastException}.
Some kind of guards ensure that the cast will not fail at the language-level,
while others only can guarantee it at the application-level.
\gh{Lang} These casts could be ameliorated if there is enough language support by changing the type system.
\gh{Analysis} The casts in this group could be checked with new analysis or compiler tools.
\gh{Auto} These casts are related to generated or boilerplate code.
\gh{Refactor} The casts with this aspect can be simply removed by the developer,
can be removed with little refactoring,
or suggest a code smell in the source code.
\gh{Generics} The casts in this category are related to generics or reified generics.
\gh{Boxing} These casts are related with explicit boxing/unboxing operations, \ie{},
explicit converting values of primitive types to boxed types back and forth.

Many programming languages provide features to ameliorate the more common use cases of casts.
For instance,
\kotlin{}'s smart casts couple together the \code{instanceof} operator and cast operation on value, 
providing direct support for the \nameref{pat:Typecase} and \nameref{pat:Equals} patterns.
More generally, ML-style pattern matching subsumes this pattern.
Smart casts do not apply directly to the \nameref{pat:OperandStack} pattern,
since it is dispatched depending on some application-specific control state.

Other language features that might at least partially obviate the need for some of the patterns are
intersection types (\cf{} \nameref{pat:ImplicitIntersectionType}),
and self types or associated types (\cf{} 
\nameref{pat:Factory},
\nameref{pat:KnownReturnType},
\nameref{pat:Deserialization},
\nameref{pat:CovariantReturnType},
\nameref{pat:FluentAPI}).
Virtual classes~\citep{gbeta, scalaIndependentlyExtensible} and languages that support family polymorphism~\citep{ernstFamilyPolymorphism2001}
would help with casts in the \nameref{pat:Family} pattern.

Some cast can be automatically generated.
The \variant{StaticResource} variant in \nameref{pat:Stash} could be generated by a GUI editor,
given that it is most seen in Android applications.
The \nameref{pat:Equals} pattern is composed of boilerplate code.
For instance, \scala{}' solves this issue by introducing \emph{case classes},
which among other features, provide equality out of the box.

Our study also suggests analyses could be performed to improve code quality and eliminate some cast usages,
for instance finding opportunities to use generics instead (\cf{} \nameref{pat:UseRawType}),
removing redundant casts (\cf{} \nameref{pat:Redundant}),
or locating code smells (\cf{}
\nameref{pat:KnownReturnType},
\nameref{pat:VariableSupertype},
\nameref{pat:ObjectAsArray}).

Many cast patterns (\eg, 
\nameref{pat:RemoveWildcard},
\nameref{pat:GenericArray},
\nameref{pat:CovariantGeneric},
\nameref{pat:UnoccupiedTypeParameter})
are used either to 
workaround---or to take advantage of---the erasure of generic type parameters in \java{}.
Reified generics or definition-site, rather than use-site,
variance annotations~\citep{altidorTamingWildcardsCombining2011}
would reduce the need for these patterns.
There is an ongoing proposal%
\footnote{\url{https://openjdk.java.net/jeps/300}}~\citep{jep300}
to enhance \java{} with this feature.

Some cast patterns use boxing/unboxing---\ie{},
\nameref{pat:UseRawType},
\nameref{pat:CovariantGeneric}, and
\nameref{pat:GenericArray}---because of the interplay between primitive types and generics.
The JEP 218 Generics over Primitive Types%
\footnote{\url{https://openjdk.java.net/jeps/218}}~\citep{jep218}
could ameliorate the situation in this aspect.
On the other hand, 
the \nameref{pat:SelectOverload} pattern uses boxing/unboxing to select the appropriate method,
while the \nameref{pat:ReflectiveAccessibility} pattern
uses unboxing when the field being accessed is of a primitive type.
