\begin{pattern}{LookupById}
This pattern is used to extract values from a heterogenous container.
It looks up an object by a compile-time constant identifier, tag, or name and casts the result to an appropriate type.
It accesses a collection that holds values of different types
(usually implemented as \code{Collection<Object>} or as \code{Map<K, Object>}).
The actual run-time type returned from the lookup is determined by the value of the identifier.

\instances{}
In the example shown below,%
\footnote{\url{http://bit.ly/loopj_android-async-http_2SUzY4E}}
the \code{getAttribute} method returns \code{Object}.
The variable \texttt{context} is of type \code{BasicHttpContext},
which is implemented with \code{HashMap}.

%https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1518514025554/files/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L258
\begin{minted}[highlightlines=1,linenos=false]{java}
AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);
\end{minted}

The next snippet%
\footnote{\url{http://bit.ly/skerit_cmusphinx_2HGgL1D}}
shows a call site to the \code{getComponent} method cast to the \code{ActiveListManager} class (line 15).
The \code{getComponent} method in this cast instance uses as argument the \code{PROP\_ACTIVE\_LIST\_MANAGER} constant.
Looking at the definition of this constant (line 3),
we can see there is a companion attribute (\code{@S4Component}) whose argument is the \code{ActiveListManager} class, the target of the cast instance.

% https://lgtm.com/projects/g/skerit/cmusphinx/snapshot/dist-1506204046584-1524814812150/files/sphinx4/src/sphinx4/edu/cmu/sphinx/decoder/search/WordPruningBreadthFirstSearchManager.java?sort=name&dir=ASC&mode=heatmap#L207
\begin{minted}[highlightlines=15]{java}
/** The property that defines the type of active list to use */
@S4Component(type = ActiveListManager.class)
public final static String PROP_ACTIVE_LIST_MANAGER = "activeListManager";

@Override
public void newProperties(PropertySheet ps) throws PropertyException {
    super.newProperties(ps);
    logMath = (LogMath) ps.getComponent(PROP_LOG_MATH);
    logger = ps.getLogger();
    linguist = (Linguist) ps.getComponent(PROP_LINGUIST);
    pruner = (Pruner) ps.getComponent(PROP_PRUNER);
    scorer = (AcousticScorer) ps.getComponent(PROP_SCORER);
    activeListManager = 
            (ActiveListManager) ps.getComponent(PROP_ACTIVE_LIST_MANAGER);
    // [...]
}
\end{minted}

A common version of this pattern is to retrieve a value instantiated from
static resource file, \eg,
an XML, HTML or \java{} properties file.
The file contents are (in theory) known at compile-time and the file is included in the binary distribution
of the application. These files are often built using tools such as GUI
builders.

In the following example from an Android application,%
\footnote{\url{http://bit.ly/pwittchen_NetworkEvents_2HGbrMq}}
a cast is applied to the \code{findViewById} method invocation.
View classes are instantiated by the application framework using an XML resource file.
The \code{findViewById} method looks up the view by its ID.

%https://lgtm.com/projects/g/pwittchen/NetworkEvents/snapshot/dist-2032650416-1524814812150/files/example/src/main/java/com/github/pwittchen/networkevents/app/MainActivity.java?sort=name&dir=ASC&mode=heatmap#L65
\begin{minted}[highlightlines=1,linenos=false]{java}
mobileNetworkType = (TextView) findViewById(R.id.mobile_network_type);
\end{minted}

\discussion{}
This pattern suggests a heterogeneous dictionary.
In our manual inspection,
all dictionary keys and the resulting types are known at
compile time, however
a cast is needed because the dictionary type does not encode the
relationship between key values and the result type.
Casts in this pattern are typically not guarded indicating that the programmer
knows the source of the cast based on the value of the key.

This pattern is often seen in Android applications.
The Butter Knife framework%
\footnote{\url{http://jakewharton.github.io/butterknife/}}
uses annotations to avoid the ``manual'' casting.
Instead, code is generated that casts the result of \code{findViewById} to the
appropriate type.


But in any case a cast is needed given the inexpressiveness of the type system.
As a complementary analysis,
it would be interesting to check whether all call sites to
\code{getAttribute} receives a constant (\code{final static} field).

Notice that this pattern is not guarded by an \code{instanceof}.
However, the cast involved does not fail at runtime.
This means that the source of the cast is known to the programmer.
This raises the following questions:
\begin{itemize}
\item \emph{What kind of analysis is needed to detect the source of the cast?}
\item \emph{Is worth to have it?}
\item \emph{Is better to change API?}
\item \emph{How other --- statically typed --- languages support this kind of idiom?}
\item \emph{Could generative programming a.k.a. templates solve this problem?}
\end{itemize}

This pattern retrieves a stashed a value from an heterogeneous collection (or dictionary).
A cast is needed because the return type depends on the ID to be retrieved.
This scenario is similar to the \nameref{pat:Tag} pattern,
where usually the developer retrieves a stashed value from a superclass field.
Since this pattern casts a value to a known type from a method invocation,
it can be seen as a kind of \nameref{pat:KnownReturnType} pattern.

\end{pattern}