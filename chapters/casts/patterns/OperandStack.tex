\begin{pattern}{OperandStack}
The \thisp{} pattern consists of
multiple cases, dispatched depending on some application-specific control state, with
  casts of the top elements of stack-like collection in each case.
An application invariant ensures that if the application is in a given state
then the 
  top elements of the stack should be of known run-time types.

\instances{}
The following example,%
\footnote{\url{http://bit.ly/fabioz_Pydev_2HF6nrF}}
shows a cast whose value is on top of a stack (line 2).
In this case, the code is transforming a parse tree into an abstract syntax
tree. The casts in the switch case are guarded by the parse tree node type and
its arity. 

%https://lgtm.com/projects/g/fabioz/Pydev/snapshot/dist-20832102-1524814812150/files/plugins/org.python.pydev.parser/src/org/python/pydev/parser/grammar27/TreeBuilder27.java?sort=name&dir=ASC&mode=heatmap#L231
\begin{minted}[highlightlines=2]{java}
case JJTASSERT_STMT:
    exprType msg = arity == 2 ? ((exprType) stack.popNode()) : null;
    test = (exprType) stack.popNode();
    return new Assert(test, msg);
\end{minted}

Similar to the previous example,
in this case%
\footnote{\url{http://bit.ly/Sable_soot_2MZLZ3m}}
a guarded cast is performed on a stack of grammar symbols.
The code was generated using an LR parser
generator. The guard 
ensures that the parser has already matched a given prefix of the
input and so the top of the stack should contain the expected symbols.

%https://lgtm.com/projects/g/Sable/soot/snapshot/dist-1791462132-1524814812150/files/src/main/generated/jastadd/soot/JastAddJ/JastAddJavaParser.java?sort=name&dir=ASC&mode=heatmap#L1036
\begin{minted}[highlightlines=4]{java}
case 40: // qualified_name_decl = name_decl.n DOT.DOT IDENTIFIER.i
{
    final Symbol _symbol_n = _symbols[offset + 1];
    final IdUse n = (IdUse) _symbol_n.value;
    final Symbol DOT = _symbols[offset + 2];
    final Symbol i = _symbols[offset + 3];
    return new IdUse(n.getID() + "." + ((String)i.value));
}
\end{minted}

\discussion{}
This pattern is usually seen when implementing grammar-related operations,
such as parsers or interpreters.

  Similar to \nameref{pat:Typecase}, multiple cases are evaluated
  with casts to different types, depending on application-specific guards.
  However, unlike 
  \nameref{pat:Typecase}, 
  the success of the casts is ensured not 
  by a type-tag-like value, but by application-specific state
  (\eg, the current parser state or the state of an evaluator)
  and proper use of the stack.

\end{pattern}
