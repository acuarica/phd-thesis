\begin{pattern}{ImplicitIntersectionType}
This pattern occurs when there is a downcast of reference $v$ of type $T$ to a
target
interface type $I$.
Although $T$ does not implement $I$, 
the cast succeeds because all possible run-time types of $v$
do implement $I$.

\instances{}
For instance, in the following example%
\def\urlvar{http://bit.ly/senbox_org_snap_desktop_2FQOt4v}
the method call returns a \code{Number}, which does not implement
\code{Comparable}; however,
all values that could be returned by the method
are subclasses of \code{Number} in \code{java.lang}
that do implement \code{Comparable}.

\begin{minted}[highlightlines=1,linenos=false]{java}
final Comparable max = (Comparable) properties.getMaxValue();
\end{minted}

Dynamic Proxy implementation
\def\urlvar{http://bit.ly/CloudSlang_cloud_slang_2EkgP4l}

%https://lgtm.com/projects/g/CloudSlang/cloud-slang/snapshot/dist-13290023-1524814812150/files/cloudslang-entities/src/main/java/io/cloudslang/lang/entities/bindings/values/PyObjectValueProxyFactory.java?sort=name&dir=ASC&mode=heatmap#L51
\begin{minted}[highlightlines=1]{java}
PyObjectValueProxyClass proxyClass = getProxyClass(pyObject);
PyObjectValue pyObjectValue = (PyObjectValue) proxyClass.getConstructor()
        .newInstance(proxyClass.getParams());
((Proxy) pyObjectValue).setHandler(new PyObjectValueMethodHandler(content, sensitive, pyObject));
\end{minted}

\discussion{}
The cast could avoided by having the operand type implement the target type
  interface or by introducing a more precise interface.
  In the above example, one could imagine an interface
  \code{ComparableNumber} that extends both \code{Number} and
  \code{Comparable}. \scala{} supports
  interface types, allowing 
  the type \code{Number with Comparable}
  to be used directly.

\end{pattern}