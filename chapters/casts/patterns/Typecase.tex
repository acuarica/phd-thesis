\begin{pattern}{Typecase}
The \thisp{} pattern consists of dispatching to different cases
depending on the run-time type of the source value.
The run-time type is tested against known subtypes of the operand type,
with each test followed by a cast to that type.
The guard may be implemented in one of three ways: an \code{instanceof} operator,
a comparison of the runtime class against a class literal,
or an application-specific type tag.

When implementing the pattern,
care must be taken with complex operands that the value of the operand is
not changed between the guard and the cast, possibly even by another thread.
For instance, in some situations the operand expression is a method invocation.
The value returned by the method should be the same for both the
\code{instanceof} and the cast, thus the method should be a pure method.
Typically, this problem is avoided by using an effectively final local variable in both the guard and the
cast operand.

\instances{}
\thisp{} is by far the most common pattern.
The following listing shows an example of the \thisp{} pattern.%
\footnote{\url{http://bit.ly/PenguinSquad_Enchiridion_2HnNwB7}}

%https://lgtm.com/projects/g/PenguinSquad/Enchiridion/snapshot/dist-19218583-1524814812150/files/build/sources/main/java/joshie/enchiridion/helpers/StackHelper.java?sort=name&dir=ASC&mode=heatmap#L27
\begin{minted}[highlightlines=6]{java}
	if (object instanceof Item) {
		return getStringFromStack(new ItemStack((Item) object));
	} else if (object instanceof Block) {
		return getStringFromStack(new ItemStack((Block) object));
	} else if (object instanceof ItemStack) {
		return getStringFromStack((ItemStack) object);
	} else if (object instanceof String) {
		return (String) object;
	} else if (object instanceof List) {
		return getStringFromStack((ItemStack) ((List) object).get(0));
	} else return "";
\end{minted}

Often there is just one case and the default case, \ie, when the guard
fails, performs a no-op or reports an error.

A particularly common instance of \thisp{} (usually with just one case) is in \code{equals} methods (223
instances out of 1,296, or 17\%).%
\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\#equals-java.lang.Object-}}
Here the pattern is used to check if the argument (of type \code{Object}) has the same type as \code{this}
in order to compare the fields of the argument with the receiver.

Another common scenario%
\footnote{\url{http://bit.ly/codefollower_Tomcat-Research_2SGDUG5}}
is when several cases are used to re-\code{throw} an exception of the right type, as shown below.
The cast instance is applied to a variable of type \code{Throwable}
(line 13).
Nevertheless, the enclosing method is only allowed to throw \code{NamingException} by the \code{throws} declaration (line 3).
Since an exception of type \code{Throwable} is checked,
a cast to \code{VirtualMachineError} (subclass of \code{Error}) is needed.

%https://lgtm.com/projects/g/codefollower/Tomcat-Research/snapshot/dist-13734061-1524814812150/files/java/org/apache/naming/factory/DataSourceLinkFactory.java?sort=name&dir=ASC&mode=heatmap#L85
\begin{minted}[highlightlines=13]{java}
protected Object wrapDataSource(
			Object datasource, String username, String password)
			throws NamingException {
	try {
		// [...]
	}catch (Exception x) {
		if (x instanceof InvocationTargetException) {
			Throwable cause = x.getCause();
			if (cause instanceof ThreadDeath) {
				throw (ThreadDeath) cause;
			}
			if (cause instanceof VirtualMachineError) {
				throw (VirtualMachineError) cause;
			}
			if (cause instanceof Exception) {
				x = (Exception) cause;
			}
		}
		if (x instanceof NamingException) throw (NamingException)x;
		else {
			// [...]
		}
	}
}
\end{minted}

The next example%
\footnote{\url{http://bit.ly/kiegroup_jbpm_2ENCL8a}}
shows that
\thisp{} can also be used to filter elements by type within a stream.
The cast is applied to stream operations (line 1) over the \code{caseAssignments} collection.
The \code{instanceof} is performed in line 1 as well.

%https://lgtm.com/projects/g/kiegroup/jbpm/snapshot/dist-1810050-1524814812150/files/jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/wih/StartCaseWorkItemHandler.java?sort=name&dir=ASC&mode=heatmap#L212
\begin{minted}[highlightlines=1]{java}
user = (User) caseAssignments.stream().filter(oe -> oe instanceof User)
                                      .findFirst()
                                      .orElseThrow(() -> new IllegalArgumentException());
\end{minted}

Rather than using an \code{instanceof},
in the following example%
\footnote{\url{http://bit.ly/JesusFreke_smali_2Ho8bVL}}
the target type of the parameter \code{reference} is determined by the value
of the parameter \code{referenceType},
which acts as a \emph{type tag} for \code{reference}.

%https://lgtm.com/projects/b/JesusFreke/smali/snapshot/dist-1306230039-1524814812150/files/dexlib2/src/main/java/org/jf/dexlib2/writer/InstructionWriter.java?sort=name&dir=ASC&mode=heatmap#L492
\begin{minted}[highlightlines=4]{java}
switch (referenceType) {
    case ReferenceType.FIELD: return fieldSection.getItemIndex((FieldRefKey) reference);
    case ReferenceType.METHOD: return methodSection.getItemIndex((MethodRefKey) reference);
    case ReferenceType.STRING: return stringSection.getItemIndex((StringRef) reference);
    case ReferenceType.TYPE: return typeSection.getItemIndex((TypeRef) reference);
    case ReferenceType.METHOD_PROTO: return protoSection.getItemIndex((ProtoRefKey) reference);
    default: throw new ExceptionWithContext("Unknown reference type: %d",  referenceType);
}
\end{minted}

In some cases, the target types of the casts are the same in every branch.
In the following snippet,%
\footnote{\url{http://bit.ly/loopj_android-async-http_2IpIULk}}
the cast is applied to the \code{message.obj} field to (line 11),
according to the value of the tag \code{message.what} field (line 1).
However, a similar cast is applied in the first branch (line 3).
In both branches \code{message.obj} is of type \code{Object[]},
  but with different lengths.
  The casts in the calls to \code{onSuccess} and
  \code{onFailure} (lines 5, 13--14) are instances of the
  \nameref{pat:ObjectAsArray} pattern.

%https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1549372228293/files/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap#L359
\begin{minted}[highlightlines=9]{java}
switch (message.what) {
    case SUCCESS_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 3) {
            onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
        } else { ... }
        break;
    case FAILURE_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 4) {
            onFailure((Integer) response[0], (Header[]) response[1],
                    (byte[]) response[2], (Throwable) response[3]);
        } else { ... }
        break;
    ...
}
\end{minted}

% There is an exploratory document%
% \footnote{\url{http://cr.openjdk.java.net/\~briangoetz/amber/datum.html}}
% by \java{} Language Architect Brian Goetz addressing these issues from a more general perspective.
% It is definitely a starting point towards improving the \java{} language.

\discussion{}
Having only a single case---that is, a single guard and cast---is common.
In the 742 instances of \thisp{} that used \code{instanceof}, 511
(69\%) had only one case.

The \thisp{} pattern can be seen as an \adhoc{} alternative to a
\code{typecase} or pattern matching~\citep{milnerProposalStandardML1984} as a
language construct.
In \kotlin{}, flow-sensitive typing is used so that immutable values can be
used at a subtype when a type guard on the value is successful.%
\footnote{\url{https://kotlinlang.org/docs/reference/typecasts.html\#smart-casts}}
This feature eliminates much of the need for the guarded casts.
Pattern matching can be seen in several other languages, \eg, \ml{}, \scala{}, \csharp{}, and \haskell{}.
For instance, in \scala{} the pattern matching construct is achieved using the \code{match} keyword.
In this example,%
\footnote{Adapted from \url{https://docs.scala-lang.org/tour/pattern-matching.html}}
a different action is taken according to the runtime type of the parameter \code{notification} (line 9).

\begin{minted}[highlightlines=10]{scala}
abstract class Notification
case class Email(sender: String, title: String, body: String)
	extends Notification
case class SMS(caller: String, message: String)
	extends Notification
case class VoiceRecording(contactName: String, link: String)
	extends Notification

def showNotification(notification: Notification): String = {
	notification match {
		case Email(email, title, _) =>
		s"You got an email from $email with title: $title"
		case SMS(number, message) =>
		s"You got an SMS from $number! Message: $message"
		case VoiceRecording(name, link) =>
		s"Voice Recording from $name! Click the link: $link"
	}
	}
	val someSms = SMS("12345", "Are you there?")
	val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")
	
	// prints You got an SMS from 12345! Message: Are you there?
	println(showNotification(someSms))
	
	// Voice Recording from Tom! Click the link: voicerecording.org/id/123	
	println(showNotification(someVoiceRecording))
\end{minted}

Alternatives to the \thisp{} pattern would be to use the visitor pattern or to
use virtual dispatch on the match scrutinee.
However, both of these
alternatives might be difficult to implement when the scrutinee is defined in
a library or in third-party code.
There is an ongoing proposal%
\footnote{\url{http://openjdk.java.net/jeps/305}}$^{,}$%
\footnote{\url{https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html}}
to add pattern matching to the \java{} language.
The proposal explores changing the \code{instanceof} operator in order to support pattern matching.
%
\done{Java 12 will (maybe) add matching.}
%
\java{} 12 extends the \code{switch} statement to be used as either a statement or an expression.%
\footnote{\url{https://openjdk.java.net/jeps/325}}
This enhancement aims to ease the transition to a \code{switch} expression that supports pattern matching.

The pattern for an \code{equals} method implementation is well-known.
Most \code{equals} methods in our sample are implemented with the same
boilerplate structure:
that is, first checking if the parameter is another reference to \code{this},
then checking if the argument is not null,
and finally, checking if the argument is of the right class
(with either an \code{instanceof} test or a \code{getClass} comparison).
Once all checks are performed, a cast follows, and a field-by-field comparison is made.

To avoid this boilerplate, other languages bake in deep equality comparisons, at least for some types
(\eg, \scala{} case classes),
or provide mechanisms to generate the boilerplate code (\eg, \code{deriving Eq}
in \haskell{} or \code{\#[derive(Eq)]} in \rust{}).
\cite{vaziriDeclarativeObjectIdentity2007} propose a declarative approach to avoid boilerplate code when implementing
both the \code{equals} and \code{hashCode} methods.




This pattern is a common pattern to implement the \code{equals} method (declared in \code{java.lang.Object}).
A cast expression is guarded by either an \code{instanceof} test or a \code{getClass} comparison (usually to the same target type as the cast);
in an \code{equals}%
\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\#equals-java.lang.Object-}} method implementation.
This is done to check if the argument has same type as the receiver
(\code{this} argument).

Notice that a cast in an \code{equals} method is needed because it
receives an \code{Object} as a parameter.

The following listing%
\footnote{\url{http://bit.ly/neo4j_neo4j_2vJw94J}}
shows an example of the \thisp{} pattern.
In this case,
\code{instanceof} is used to guard for the same type as the receiver.

%https://lgtm.com/projects/g/neo4j/neo4j/snapshot/dist-15760049-1519892555006/files/community/kernel/src/main/java/org/neo4j/kernel/impl/api/CountsRecordState.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L182
\begin{minted}[highlightlines=7]{java}
@Override
public boolean equals(Object obj) {
    if ( this == obj ) {
        return true;
    }
    if ( (obj instanceof Difference) ) {
        Difference that = (Difference) obj;
        return actualFirst == that.actualFirst
          && expectedFirst == that.expectedFirst
          && actualSecond == that.actualSecond 
          && expectedSecond == that.expectedSecond
          && key.equals( that.key );
    }
    return false;
}
\end{minted}

Alternatively, the following listing%
\footnote{\url{http://bit.ly/neo4j_neo4j_2vKP0MW}}
shows another example of the \thisp{} pattern.
But in this case,
a \code{getClass} comparison is used to guard for the same type as the receiver (line 4).

%https://lgtm.com/projects/g/neo4j/neo4j/snapshot/dist-15760049-1519892555006/files/community/bolt/src/main/java/org/neo4j/bolt/v1/messaging/infrastructure/ValuePath.java?sort=name&dir=ASC&mode=heatmap&excluded=false#L278
\begin{minted}[highlightlines=7]{java}
@Override
public boolean equals( Object o ) {
    if ( this == o ) return true;
    if ( o == null || getClass() != o.getClass() )
        return false;

    ValuePath that = (ValuePath) o;
    return nodes.equals(that.nodes) &&
        relationships.equals(that.relationships);
}
\end{minted}

In some situations, the type cast is not the same as the enclosing class.
Instead, the type cast is the super class of the enclosing class.
The following example%
\footnote{\url{http://bit.ly/square_sqlbrite_2HmHMYE}}
shows this scenario.
This happens, for example, when the Google AutoValue library%
\footnote{\url{https://github.com/google/auto/tree/master/value}}
is used.
AutoValue is a code generator for value classes.

%https://lgtm.com/projects/g/square/sqlbrite/snapshot/3a9916985485ba5922097fe59a18230500f02df4/files/sample/build/generated/source/apt/debug/com/example/sqlbrite/todo/ui/$AutoValue_ListsItem.java?sort=name&dir=ASC&mode=heatmap&showExcluded=false#L52
\begin{minted}[highlightlines=13]{java}
@AutoValue
abstract class ListsItem implements Parcelable {
    // [...]
}

abstract class $AutoValue_ListsItem extends ListsItem {
    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof ListsItem) {
        ListsItem that = (ListsItem) o;
        return (this.id == that.id())
             && (this.name.equals(that.name()))
             && (this.itemCount == that.itemCount());
      }
      return false;
    }
}
\end{minted}

The following snippet%
\footnote{\url{http://bit.ly/bndtools_bnd_2SM5pOw}}
shows a non-trivial implementation of \code{equals}.
The enclosing class of the \code{equals} method is \code{CapReq} (line 1).
However, the cast instance (line 13) is not against the enclosing class,
it is against to the \code{Requirement} class.
Note that the cast using the enclosing class as target type is in line 9.

%https://lgtm.com/projects/g/bndtools/bnd/snapshot/dist-930051-1524814812150/files/biz.aQute.bndlib/src/aQute/bnd/osgi/resource/CapReq.java?sort=name&dir=ASC&mode=heatmap#L73
\begin{minted}[highlightlines=13]{java}
class CapReq {
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
                return true;
        if (obj == null)
                return false;
        if (obj instanceof CapReq)
                return equalsNative((CapReq) obj);
        if ((mode == MODE.Capability) && (obj instanceof Capability))
                return equalsCap((Capability) obj);
        if ((mode == MODE.Requirement) && (obj instanceof Requirement))
                return equalsReq((Requirement) obj);
        return false;
    }
}
\end{minted}


\discussion{}
The pattern for an \code{equals} method implementation is well-known.
We found out that most \code{equals} methods are implemented with the same structure.
That is, first checking if the parameter is another reference to the receiver object;
then checking if the argument is not null;
and at last, checking if the argument is of the right class
(with either an \code{instanceof} test or a \code{getClass} comparison).
Once all checks are performed, a cast follows, and a field-by-field comparison is made.
Usually this leads to boilerplate code.
\done{Matthias: This sentence needs to be expanded (add something before)}
\java{} could provide a mechanism to avoid boilerplate code by providing code generation,
%
\done{Nate: \rust{} traits too. \code{\#[derive(Eq)]} }
%
like in \haskell{} with \code{deriving},
\scala{} (with case classes), or
\rust{} (with \code{derive(Eq)}).

\cite{vaziriDeclarativeObjectIdentity2007} propose a declarative approach to avoid boilerplate code when implementing both the \code{equals} and \code{hashCode} methods.
They manually analyzed several applications, and found there are many issues while implementing \code{equals()} and \code{hashCode()} methods.
It would be interesting to check whether these issues happen in real application code.

There is an exploratory document%
\footnote{\url{http://cr.openjdk.java.net/\~briangoetz/amber/datum.html}}
by Brian Goetz --- \java{} Language Architect --- addressing these issues from a more general perspective.
It is definitely a starting point towards improving the \java{} language.

This pattern can be seen as a special instance of the \nameref{pat:Typecase} pattern when the guard is an \code{instanceof} test.





A cast is using an application-specific guard,
but the guard depends on a class literal.

\instances{}
The following example%
\footnote{\url{http://bit.ly/elastic_elasticsearch_2SSgsFV}}
shows an instance of the \thisp{} pattern.
A cast is performed to the \code{field} variable (line 22),
based whether the runtime class of the variable is actually \code{Short.class}.

%https://lgtm.com/projects/g/elastic/elasticsearch/snapshot/dist-1916470085-1524814812150/files/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java?sort=name&dir=ASC&mode=heatmap#L478
\begin{minted}[highlightlines=22]{java}
Class type = field.getClass();
if (type == String.class) {
    out.writeByte((byte) 1);
    out.writeString((String) field);
} else if (type == Integer.class) {
    out.writeByte((byte) 2);
    out.writeInt((Integer) field);
} else if (type == Long.class) {
    out.writeByte((byte) 3);
    out.writeLong((Long) field);
} else if (type == Float.class) {
    out.writeByte((byte) 4);
    out.writeFloat((Float) field);
} else if (type == Double.class) {
    out.writeByte((byte) 5);
    out.writeDouble((Double) field);
} else if (type == Byte.class) {
    out.writeByte((byte) 6);
    out.writeByte((Byte) field);
} else if (type == Short.class) {
    out.writeByte((byte) 7);
    out.writeShort((Short) field);
} else if (type == Boolean.class) {
    out.writeByte((byte) 8);
    out.writeBoolean((Boolean) field);
} else if (type == BytesRef.class) {
    out.writeByte((byte) 9);
    out.writeBytesRef((BytesRef) field);
} else {
    throw new IOException("Can't handle sort field value of type ["+type+"]");
}
\end{minted}

In the following listing,%
\footnote{\url{http://bit.ly/smartdevicelink_sdl_android_2EjJiaq}}
a cast is applied to the result of the \code{getObject} method (line 2).
The target type of the cast, \code{MyKey}, corresponds to the class literal argument, \code{MyKey.class}.
Essentially, \code{getObject} is using the \code{isInstance} method%
\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html\#isInstance-java.lang.Object-}}
of the class \code{java.lang.Class} to check whether an object is from a certain type.

%https://lgtm.com/projects/g/smartdevicelink/sdl_android/snapshot/dist-2037360569-1524814812150/files/sdl_android/src/main/java/com/smartdevicelink/proxy/rpc/GetVehicleDataResponse.java?sort=name&dir=ASC&mode=heatmap#L236
\begin{minted}[highlightlines=2]{java}
public MyKey getMyKey() {
    return (MyKey) getObject(MyKey.class, KEY_MY_KEY);
} 
\end{minted}

Similar to the first example, the next snippet%
\footnote{\url{http://bit.ly/OPCFoundation_UA-Java-Legacy_2Fb2xmZ}}
contains several type cases.
Each type case is guarded by an \code{equals} comparison between a class literal and the \code{clazz} parameter.
The cast is applied to the type parameter \code{T} only if the guard succeeds.

%https://lgtm.com/projects/g/OPCFoundation/UA-Java-Legacy/snapshot/dist-1804064538-1524814812150/files/src/main/java/org/opcfoundation/ua/encoding/binary/BinaryDecoder.java?sort=name&dir=ASC&mode=heatmap#L214
\begin{minted}[highlightlines=9]{java}
@Override
@SuppressWarnings("unchecked")
public <T> T get(String fieldName, Class<T> clazz) throws DecodingException {
    if (clazz.equals(Boolean.class)) {
        return (T) getBoolean(fieldName);
    }
    // [...]
    if (clazz.equals(ExtensionObject.class)) {
        return (T) getExtensionObject(fieldName);
    }
    // [...]
}
\end{minted}

The following snippet%
\footnote{\url{http://bit.ly/apache_karaf_2HE55gE}}
shows an instance of the \thisp{} pattern. 
In this case, the cast is guaranteed to succeed because the class literal used as argument to the recursive call (\code{Integer.class}) determines that the method returns an \code{int} value.

%https://lgtm.com/projects/g/apache/karaf/snapshot/dist-13960098-1524814812150/files/shell/core/src/main/java/org/apache/karaf/shell/support/converter/DefaultConverter.java?sort=name&dir=ASC&mode=heatmap#L117
\begin{minted}[highlightlines=4]{java}
public Object convertToNumber(Number value, Class toType) throws Exception {
    toType = unwrap(toType);
    if (AtomicInteger.class == toType) {
        return new AtomicInteger((Integer)convertToNumber(value,Integer.class));
    } else if (AtomicLong.class == toType) {
        return new AtomicLong((Long) convertToNumber(value, Long.class));
    } else if (Integer.class == toType) {
        return value.intValue();
    } else if (Short.class == toType) {
        return value.shortValue();
    } else if (Long.class == toType) {
        return value.longValue();
    } else if (Float.class == toType) {
        return value.floatValue();
    } else if (Double.class == toType) {
        return value.doubleValue();
    } else if (Byte.class == toType) {
        return value.byteValue();
    } else if (BigInteger.class == toType) {
        return new BigInteger(value.toString());
    } else if (BigDecimal.class == toType) {
        return new BigDecimal(value.toString());
    } else {
        throw new Exception("Unable to convert number "+value+" to "+toType);
    }
}
\end{minted}

This pattern may be used instead of \nameref{pat:Typecase} when the developer wants to match exactly the runtime class.
The \code{instanceof} operator%
\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html\#jls-15.20.2}}
returns \code{true} if the expression could be cast to the specified type,
whereas using a class literal comparison returns \code{true} if the expression is exactly the runtime class.

As discussed above, it is related to \nameref{pat:Typecase} but this pattern uses an exact match of the runtime class.





A cast instance belonging to the \thisp{} pattern is guarded by an application-specific test instead of using an \code{instanceof} test.

The following example%
\footnote{\url{http://bit.ly/JesusFreke_smali_2Ho8bVL}}
shows an instance of the \thisp{} pattern.
The cast type of the parameter \code{reference} is determined by the value of the parameter \code{referenceType}.

%https://lgtm.com/projects/b/JesusFreke/smali/snapshot/dist-1306230039-1524814812150/files/dexlib2/src/main/java/org/jf/dexlib2/writer/InstructionWriter.java?sort=name&dir=ASC&mode=heatmap#L492
\begin{minted}[highlightlines=8]{java}
private int getReferenceIndex(int referenceType, Reference reference) {
    switch (referenceType) {
        case ReferenceType.FIELD:
            return fieldSection.getItemIndex((FieldRefKey) reference);
        case ReferenceType.METHOD:
            return methodSection.getItemIndex((MethodRefKey) reference);
        case ReferenceType.STRING:
            return stringSection.getItemIndex((StringRef) reference);
        case ReferenceType.TYPE:
            return typeSection.getItemIndex((TypeRef) reference);
        case ReferenceType.METHOD_PROTO:
            return protoSection.getItemIndex((ProtoRefKey) reference);
        default:
            throw new ExceptionWithContext(
                "Unknown reference type: %d",  referenceType);
    }
}
\end{minted}

In the next example,%
\footnote{\url{http://bit.ly/FenixEdu_fenixedu-academic_2SUNOUJ}}
instead of a \code{switch} statement,
an \code{if} statement is used to guard the cast (in line 6).

%https://lgtm.com/projects/g/FenixEdu/fenixedu-academic/snapshot/dist-29270029-1524814812150/files/src/main/java/org/fenixedu/academic/ui/renderers/student/curriculum/StudentCurricularPlanRenderer.java?sort=name&dir=ASC&mode=heatmap#L853
\begin{minted}[highlightlines=6]{java}
for (final IEnrolment enrolment : dismissal.getSourceIEnrolments()) {
    if (enrolment.isExternalEnrolment()) {
        generateExternalEnrolmentRow(mainTable, (ExternalEnrolment) enrolment,
                level + 1, true);
    } else {
        generateEnrolmentRow(mainTable, (Enrolment) enrolment,
                level + 1, false, true, true);
    }
}
\end{minted}

\done{Nate: Why is this not pattern matching?}
%
In the next case%
\footnote{\url{http://bit.ly/apache_poi_2FW5SXU}}
a type test is performed --- through a method call --- before actually applying the cast to the variable \code{props} (line 3).
Note that the type test is internally using the \code{instanceof} operator (line 8).
Although in this case the type test is using an \code{instanceof} operator,
it is not considered \nameref{pat:Typecase} because the \code{instanceof} is located in a method call.

%https://lgtm.com/projects/g/apache/poi/snapshot/dist-1790760597-1524814812150/files/src/ooxml/java/org/apache/poi/xslf/usermodel/XSLFPropertiesDelegate.java?sort=name&dir=ASC&mode=heatmap#L1367
\begin{minted}[highlightlines=3]{java}
@Override
public CTSolidColorFillProperties getSolidFill() {
    return isSetSolidFill() ? (CTSolidColorFillProperties)props : null;
}

@Override
public boolean isSetSolidFill() {
    return (props instanceof CTSolidColorFillProperties);
}
\end{minted}

In some cases, the type to be cast is the same in every branch.
The following snippet%
\footnote{\url{http://bit.ly/loopj_android-async-http_2IpIULk}}
shows an instance of this case.
The cast is applied to the \code{message.obj} field to (line 13),
according to the value of the \code{message.what} field (line 1).
However, a similar cast is applied in the first branch (line 3).
In both branches \code{message.obj} is of type \code{Object[]},
but in the case of \code{FAILURE\_MESSAGE},
the array contains one more element (line 16).
This suggests that the \code{(Object[]) message.obj} array denotes two different objects,
but are not distinguishable from the type system perspective.

%https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1549372228293/files/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap#L359
\begin{minted}[highlightlines=13]{java}
switch (message.what) {
    case SUCCESS_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 3) {
            onSuccess((Integer) response[0], (Header[]) response[1],
                    (byte[]) response[2]);
        } else {
            AsyncHttpClient.log.e(LOG_TAG, 
                    "SUCCESS_MESSAGE didn't got enough params");
        }
        break;
    case FAILURE_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 4) {
            onFailure((Integer) response[0], (Header[]) response[1],
                    (byte[]) response[2], (Throwable) response[3]);
        } else {
            AsyncHttpClient.log.e(LOG_TAG,
                    "FAILURE_MESSAGE didn't got enough params");
        }
        break;
    // [...]
}
\end{minted}

In the next example,%
\footnote{\url{http://bit.ly/groovy_groovy-core_2SGzK16}}
the parameter \code{args} is cast to \code{Object[]} (line 13).
The ``type tag'' is given by the fact that the cast is executed in a \code{catch} block,
and that \code{value} is an instance of \code{Closure} (line 9).
The \code{args} parameter flows into two methods,
\code{invokeMethod(String name, Object args)}
and
\code{call(Object... args)}%
.
Thus, \code{args} is treated as an \code{Object} or \code{Object[]} depending on the type tag,
resembling an union type.

%https://lgtm.com/projects/g/groovy/groovy-core/snapshot/dist-45390050-1524814812150/files/src/main/groovy/util/Expando.java?sort=name&dir=ASC&mode=heatmap#L103
\begin{minted}[highlightlines=13]{java}
public Object invokeMethod(String name, Object args) {
    try {
        return super.invokeMethod(name, args);
    }
    catch (GroovyRuntimeException e) {
        // br should get a "native" property match first.
        // getProperty includes such fall-back logic
        Object value = this.getProperty(name);
        if (value instanceof Closure) {
            Closure closure = (Closure) value;
            closure = (Closure) closure.clone();
            closure.setDelegate(this);
            return closure.call((Object[]) args);
        } else {
            throw e;
        }
    }
}
\end{minted}

In some cases, the \thisp{} pattern can be replaced by \nameref{pat:Typecase}.
However, if the application-specific tag is a numeric value,
the \thisp{} could perform better than the \nameref{pat:Typecase} using \code{instanceof}.
Moreover, there are situation where the \thisp{} can not be avoid since the types to be cast are the same.

This pattern is related to \nameref{pat:Typecase} since both denoted guarded casts.
The difference is that \thisp{} uses an application-specific test.





\end{pattern}
