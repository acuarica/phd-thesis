\begin{pattern}{Typecase}
The \thisp{} pattern consists of dispatching to different cases
depending on the run-time type of the source value.
The run-time type is tested against known subtypes of the operand type,
with each test followed by a cast to that type.
The guard may be implemented in one of three ways: an \code{instanceof} operator,
a comparison of the runtime class against a class literal,
or an application-specific type tag.

When implementing the pattern,
care must be taken with complex operands that the value of the operand is
not changed between the guard and the cast, possibly even by another thread.
For instance, in some situations the operand expression is a method invocation.
The value returned by the method should be the same for both the
\code{instanceof} and the cast, thus the method should be a pure method.
Typically, this problem is avoided by using an effectively final local variable in both the guard and the
cast operand.

\instances{}
\thisp{} is by far the most common pattern.
The following listing shows an example of the \thisp{} pattern.%
\footnote{\url{http://bit.ly/PenguinSquad_Enchiridion_2HnNwB7}}

%https://lgtm.com/projects/g/PenguinSquad/Enchiridion/snapshot/dist-19218583-1524814812150/files/build/sources/main/java/joshie/enchiridion/helpers/StackHelper.java?sort=name&dir=ASC&mode=heatmap#L27
\begin{minted}[highlightlines=6]{java}
	if (object instanceof Item) {
		return getStringFromStack(new ItemStack((Item) object));
	} else if (object instanceof Block) {
		return getStringFromStack(new ItemStack((Block) object));
	} else if (object instanceof ItemStack) {
		return getStringFromStack((ItemStack) object);
	} else if (object instanceof String) {
		return (String) object;
	} else if (object instanceof List) {
		return getStringFromStack((ItemStack) ((List) object).get(0));
	} else return "";
\end{minted}

Often there is just one case and the default case, \ie, when the guard
fails, performs a no-op or reports an error.

A particularly common instance of \thisp{} (usually with just one case) is in \code{equals} methods (223
instances out of 1,296, or 17\%).%
\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\#equals-java.lang.Object-}}
Here the pattern is used to check if the argument (of type \code{Object}) has the same type as \code{this}
in order to compare the fields of the argument with the receiver.

Another common scenario%
\footnote{\url{http://bit.ly/codefollower_Tomcat-Research_2SGDUG5}}
is when several cases are used to re-\code{throw} an exception of the right type, as shown below.
The cast instance is applied to a variable of type \code{Throwable}
(line 13).
Nevertheless, the enclosing method is only allowed to throw \code{NamingException} by the \code{throws} declaration (line 3).
Since an exception of type \code{Throwable} is checked,
a cast to \code{VirtualMachineError} (subclass of \code{Error}) is needed.

%https://lgtm.com/projects/g/codefollower/Tomcat-Research/snapshot/dist-13734061-1524814812150/files/java/org/apache/naming/factory/DataSourceLinkFactory.java?sort=name&dir=ASC&mode=heatmap#L85
\begin{minted}[highlightlines=13]{java}
protected Object wrapDataSource(
			Object datasource, String username, String password)
			throws NamingException {
	try {
		// [...]
	}catch (Exception x) {
		if (x instanceof InvocationTargetException) {
			Throwable cause = x.getCause();
			if (cause instanceof ThreadDeath) {
				throw (ThreadDeath) cause;
			}
			if (cause instanceof VirtualMachineError) {
				throw (VirtualMachineError) cause;
			}
			if (cause instanceof Exception) {
				x = (Exception) cause;
			}
		}
		if (x instanceof NamingException) throw (NamingException)x;
		else {
			// [...]
		}
	}
}
\end{minted}

The next example%
\footnote{\url{http://bit.ly/kiegroup_jbpm_2ENCL8a}}
shows that
\thisp{} can also be used to filter elements by type within a stream.
The cast is applied to stream operations (line 1) over the \code{caseAssignments} collection.
The \code{instanceof} is performed in line 1 as well.

%https://lgtm.com/projects/g/kiegroup/jbpm/snapshot/dist-1810050-1524814812150/files/jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/wih/StartCaseWorkItemHandler.java?sort=name&dir=ASC&mode=heatmap#L212
\begin{minted}[highlightlines=1]{java}
user = (User) caseAssignments.stream().filter(oe -> oe instanceof User)
                                      .findFirst()
                                      .orElseThrow(() -> new IllegalArgumentException());
\end{minted}

Rather than using an \code{instanceof},
in the following example%
\footnote{\url{http://bit.ly/JesusFreke_smali_2Ho8bVL}}
the target type of the parameter \code{reference} is determined by the value
of the parameter \code{referenceType},
which acts as a \emph{type tag} for \code{reference}.

%https://lgtm.com/projects/b/JesusFreke/smali/snapshot/dist-1306230039-1524814812150/files/dexlib2/src/main/java/org/jf/dexlib2/writer/InstructionWriter.java?sort=name&dir=ASC&mode=heatmap#L492
\begin{minted}[highlightlines=4]{java}
switch (referenceType) {
    case ReferenceType.FIELD: return fieldSection.getItemIndex((FieldRefKey) reference);
    case ReferenceType.METHOD: return methodSection.getItemIndex((MethodRefKey) reference);
    case ReferenceType.STRING: return stringSection.getItemIndex((StringRef) reference);
    case ReferenceType.TYPE: return typeSection.getItemIndex((TypeRef) reference);
    case ReferenceType.METHOD_PROTO: return protoSection.getItemIndex((ProtoRefKey) reference);
    default: throw new ExceptionWithContext("Unknown reference type: %d",  referenceType);
}
\end{minted}

In some cases, the target types of the casts are the same in every branch.
In the following snippet,%
\footnote{\url{http://bit.ly/loopj_android-async-http_2IpIULk}}
the cast is applied to the \code{message.obj} field to (line 11),
according to the value of the tag \code{message.what} field (line 1).
However, a similar cast is applied in the first branch (line 3).
In both branches \code{message.obj} is of type \code{Object[]},
  but with different lengths.
  The casts in the calls to \code{onSuccess} and
  \code{onFailure} (lines 5, 13--14) are instances of the
  \nameref{pat:ObjectAsArray} pattern.

%https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1549372228293/files/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap#L359
\begin{minted}[highlightlines=9]{java}
switch (message.what) {
    case SUCCESS_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 3) {
            onSuccess((Integer) response[0], (Header[]) response[1], (byte[]) response[2]);
        } else { ... }
        break;
    case FAILURE_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 4) {
            onFailure((Integer) response[0], (Header[]) response[1],
                    (byte[]) response[2], (Throwable) response[3]);
        } else { ... }
        break;
    ...
}
\end{minted}

% There is an exploratory document%
% \footnote{\url{http://cr.openjdk.java.net/\~briangoetz/amber/datum.html}}
% by \java{} Language Architect Brian Goetz addressing these issues from a more general perspective.
% It is definitely a starting point towards improving the \java{} language.

\discussion{}
Having only a single case---that is, a single guard and cast---is common.
In the 742 instances of \thisp{} that used \code{instanceof}, 511
(69\%) had only one case.

The \thisp{} pattern can be seen as an \adhoc{} alternative to a
\code{typecase} or pattern matching~\citep{milnerProposalStandardML1984} as a
language construct.
In \kotlin{}, flow-sensitive typing is used so that immutable values can be
used at a subtype when a type guard on the value is successful.%
\footnote{\url{https://kotlinlang.org/docs/reference/typecasts.html\#smart-casts}}
This feature eliminates much of the need for the guarded casts.
Pattern matching can be seen in several other languages, \eg, \ml{}, \scala{}, \csharp{}, and \haskell{}.
For instance, in \scala{} the pattern matching construct is achieved using the \code{match} keyword.
In this example,%
\footnote{Adapted from \url{https://docs.scala-lang.org/tour/pattern-matching.html}}
a different action is taken according to the runtime type of the parameter \code{notification} (line 9).

\begin{minted}[highlightlines=10]{scala}
abstract class Notification
case class Email(sender: String, title: String, body: String)
	extends Notification
case class SMS(caller: String, message: String)
	extends Notification
case class VoiceRecording(contactName: String, link: String)
	extends Notification

def showNotification(notification: Notification): String = {
	notification match {
		case Email(email, title, _) =>
		s"You got an email from $email with title: $title"
		case SMS(number, message) =>
		s"You got an SMS from $number! Message: $message"
		case VoiceRecording(name, link) =>
		s"Voice Recording from $name! Click the link: $link"
	}
	}
	val someSms = SMS("12345", "Are you there?")
	val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")
	
	// prints You got an SMS from 12345! Message: Are you there?
	println(showNotification(someSms))
	
	// Voice Recording from Tom! Click the link: voicerecording.org/id/123	
	println(showNotification(someVoiceRecording))
\end{minted}

Alternatives to the \thisp{} pattern would be to use the visitor pattern or to
use virtual dispatch on the match scrutinee.
However, both of these
alternatives might be difficult to implement when the scrutinee is defined in
a library or in third-party code.
There is an ongoing proposal%
\footnote{\url{http://openjdk.java.net/jeps/305}}$^{,}$%
\footnote{\url{https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html}}
to add pattern matching to the \java{} language.
The proposal explores changing the \code{instanceof} operator in order to support pattern matching.
%
\done{Java 12 will (maybe) add matching.}
%
\java{} 12 extends the \code{switch} statement to be used as either a statement or an expression.%
\footnote{\url{https://openjdk.java.net/jeps/325}}
This enhancement aims to ease the transition to a \code{switch} expression that supports pattern matching.

The pattern for an \code{equals} method implementation is well-known.
Most \code{equals} methods in our sample are implemented with the same
boilerplate structure:
that is, first checking if the parameter is another reference to \code{this},
then checking if the argument is not null,
and finally, checking if the argument is of the right class
(with either an \code{instanceof} test or a \code{getClass} comparison).
Once all checks are performed, a cast follows, and a field-by-field comparison is made.

To avoid this boilerplate, other languages bake in deep equality comparisons, at least for some types
(\eg, \scala{} case classes),
or provide mechanisms to generate the boilerplate code (\eg, \code{deriving Eq}
in \haskell{} or \code{\#[derive(Eq)]} in \rust{}).
\cite{vaziriDeclarativeObjectIdentity2007} propose a declarative approach to avoid boilerplate code when implementing
both the \code{equals} and \code{hashCode} methods.

\end{pattern}
