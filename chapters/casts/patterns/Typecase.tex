\begin{pattern}{Typecase}
The \thisp{} pattern consists of dispatching to different cases
depending on the run-time type of the source value.
The run-time type is tested against known subtypes of the operand type,
with each test followed by a cast to that type.
The guard may be implemented using one of three variants:
an \code{instanceof} operator (\variant{GuardByInstanceOf}),
a comparison of the runtime class against a class literal (\variant{GuardByClassLiteral}),
or an application-specific type tag (\variant{GuardByTypeTag}).

\instances{}
\thisp{} is by far the most common pattern.
Figure~\ref{fig:casts:typecase} shows the different variants of the pattern.
The \variant{GuardByInstanceOf} is the most used variant.
Often there is just one case and the default case, \ie,
when the guard fails, performs a no-op or reports an error.

\plot{patterns/table-pattern-Typecase-features}{fig:casts:typecase}{\thisp{} Variants Occurrences}

The following listing shows an example of the \thisp{} pattern,
using the \variant{GuardByInstanceOf} variant.

%https://lgtm.com/projects/g/PenguinSquad/Enchiridion/snapshot/dist-19218583-1524814812150/files/build/sources/main/java/joshie/enchiridion/helpers/StackHelper.java?sort=name&dir=ASC&mode=heatmap#L27
\def\urlvar{http://bit.ly/PenguinSquad_Enchiridion_2HnNwB7}
\begin{minted}[highlightlines=6]{java}
if (object instanceof Item) {
	return getStringFromStack(new ItemStack((Item) object));
} else if (object instanceof Block) {
	return getStringFromStack(new ItemStack((Block) object));
} else if (object instanceof ItemStack) {
	return getStringFromStack((ItemStack) object);
} else if (object instanceof String) {
	return (String) object;
} else if (object instanceof List) {
	return getStringFromStack((ItemStack) ((List) object).get(0));
} else return ""; #\urlbox#
\end{minted}

Another common scenario is when several cases are used to re-\code{throw}
an exception of the right type, as shown below.
The cast instance is applied to a variable of type \code{Throwable}
(line 13).
Nevertheless, the enclosing method is only allowed to throw \code{NamingException} by the \code{throws} declaration (line 3).
Since an exception of type \code{Throwable} is checked,
a cast to \code{VirtualMachineError} (subclass of \code{Error}) is needed.

%https://lgtm.com/projects/g/codefollower/Tomcat-Research/snapshot/dist-13734061-1524814812150/files/java/org/apache/naming/factory/DataSourceLinkFactory.java?sort=name&dir=ASC&mode=heatmap#L85
\def\urlvar{http://bit.ly/codefollower_Tomcat_Research_2SGDUG5}
\begin{minted}[highlightlines=13]{java}
protected Object wrapDataSource(
			Object datasource, String username, String password)
			throws NamingException {
	try {
		// [...]
	}catch (Exception x) {
		if (x instanceof InvocationTargetException) {
			Throwable cause = x.getCause();
			if (cause instanceof ThreadDeath) {
				throw (ThreadDeath) cause;
			}
			if (cause instanceof VirtualMachineError) {
				throw (VirtualMachineError) cause;
			}
			if (cause instanceof Exception) {
				x = (Exception) cause;
			}
		}
		if (x instanceof NamingException) throw (NamingException)x;
		else {
			// [...]
		}
	}
} #\urlbox#
\end{minted}

The next example shows that \thisp{} can also be used to filter elements by type within a stream.
The cast is applied to stream operations (line 1) over the \code{caseAssignments} collection.
The \code{instanceof} guard is tested in line 1 as well.

%https://lgtm.com/projects/g/kiegroup/jbpm/snapshot/dist-1810050-1524814812150/files/jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/wih/StartCaseWorkItemHandler.java?sort=name&dir=ASC&mode=heatmap#L212
\def\urlvar{http://bit.ly/kiegroup_jbpm_2ENCL8a}
\begin{minted}[highlightlines=1]{java}
user = (User) caseAssignments.stream().filter(oe -> oe instanceof User)
                                      .findFirst()
                                      .orElseThrow(() -> new IllegalArgumentException());
#\urlbox#
\end{minted}

Rather than using an \code{instanceof} guard, in the following example
the target type of the parameter \code{reference} is determined by the value
of the parameter \code{referenceType},
which acts as a \emph{type tag} for \code{reference}.

%https://lgtm.com/projects/b/JesusFreke/smali/snapshot/dist-1306230039-1524814812150/files/dexlib2/src/main/java/org/jf/dexlib2/writer/InstructionWriter.java?sort=name&dir=ASC&mode=heatmap#L492
\def\urlvar{http://bit.ly/JesusFreke_smali_2Ho8bVL}
\begin{minted}[highlightlines=7]{java}
switch (referenceType) {
    case ReferenceType.FIELD:
        return fieldSection.getItemIndex((FieldRefKey) reference);
    case ReferenceType.METHOD:
        return methodSection.getItemIndex((MethodRefKey) reference);
    case ReferenceType.STRING:
        return stringSection.getItemIndex((StringRef) reference);
    case ReferenceType.TYPE:
        return typeSection.getItemIndex((TypeRef) reference);
    case ReferenceType.METHOD_PROTO:
        return protoSection.getItemIndex((ProtoRefKey) reference);
    default:
        throw new ExceptionWithContext("Unknown reference type: %d", referenceType);
} #\urlbox#
\end{minted}

In some cases, the target types of the casts are the same in every branch.
In the following snippet,
the cast is applied to the \code{message.obj} field to (line 11),
according to the value of the tag \code{message.what} field (line 1).
However, a similar cast is applied in the first branch (line 3).
In both branches \code{message.obj} is of type \code{Object[]},
but with different lengths.
The casts in the calls to \code{onSuccess} and
\code{onFailure} (lines 5, 13--14)
are instances of the \nameref{pat:ObjectAsArray} pattern.

%https://lgtm.com/projects/g/loopj/android-async-http/snapshot/dist-1879340034-1549372228293/files/library/src/main/java/com/loopj/android/http/AsyncHttpResponseHandler.java?sort=name&dir=ASC&mode=heatmap#L359
\def\urlvar{http://bit.ly/loopj_android_async_http_2IpIULk}
\begin{minted}[highlightlines=10]{java}
switch (message.what) {
    case SUCCESS_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 3) {
            onSuccess((Integer) response[0], (Header[]) response[1],
					(byte[]) response[2]);
        } else { /* [...] */ }
        break;
    case FAILURE_MESSAGE:
        response = (Object[]) message.obj;
        if (response != null && response.length >= 4) {
            onFailure((Integer) response[0], (Header[]) response[1],
                    (byte[]) response[2], (Throwable) response[3]);
        } else { /* [...] */ }
        break;
    // [...]
} #\urlbox#
\end{minted}


\detection{}
When implementing the pattern,
care must be taken with complex operands that the value of the operand is
not changed between the guard and the cast, possibly even by another thread.
For instance, in some situations the operand expression is a method invocation.
The value returned by the method should be the same for both the
\code{instanceof} and the cast, thus the method should be a pure method.
Typically, this problem is avoided by using an effectively final local variable in both the guard and the
cast operand.

\discussion{}
Having only a single case---that is, a single guard and cast---is common.
In the 742 instances of \thisp{} that used \code{instanceof}, 511
(69\%) had only one case.

The \thisp{} pattern can be seen as an \adhoc{} alternative to a
\code{typecase} or pattern matching~\citep{milnerProposalStandardML1984} as a
language construct.
In \kotlin{}, flow-sensitive typing is used so that immutable values can be
used at a subtype when a type guard on the value is successful.%
\footnote{\url{https://kotlinlang.org/docs/reference/typecasts.html\#smart-casts}}
This feature eliminates much of the need for the guarded casts.
Pattern matching can be seen in several other languages, \eg, \ml{}, \scala{}, \csharp{}, and \haskell{}.
For instance, in \scala{} the pattern matching construct is achieved using the \code{match} keyword.
In this example,%
\footnote{Adapted from \url{https://docs.scala-lang.org/tour/pattern-matching.html}}
a different action is taken according to the runtime type of the parameter \code{notification} (line 10).

\begin{minted}[highlightlines=10]{scala}
abstract class Notification
case class Email(sender: String, title: String, body: String)
	extends Notification
case class SMS(caller: String, message: String)
	extends Notification
case class VoiceRecording(contactName: String, link: String)
	extends Notification

def showNotification(notification: Notification): String = {
	notification match {
		case Email(email, title, _) =>
		s"You got an email from $email with title: $title"
		case SMS(number, message) =>
		s"You got an SMS from $number! Message: $message"
		case VoiceRecording(name, link) =>
		s"Voice Recording from $name! Click the link: $link"
	}
	}
	val someSms = SMS("12345", "Are you there?")
	val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")
	
	// prints You got an SMS from 12345! Message: Are you there?
	println(showNotification(someSms))
	
	// Voice Recording from Tom! Click the link: voicerecording.org/id/123	
	println(showNotification(someVoiceRecording))
\end{minted}

Alternatives to the \thisp{} pattern would be to use the visitor pattern or to
use virtual dispatch on the match scrutinee.
However, both of these
alternatives might be difficult to implement when the scrutinee is defined in
a library or in third-party code.
There is an ongoing proposal%
\footnote{\url{http://openjdk.java.net/jeps/305}}$^{,}$%
\footnote{\url{https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html}}
to add pattern matching to the \java{} language.
The proposal explores changing the \code{instanceof} operator in order to support pattern matching.
\java{} 12 extends the \code{switch} statement to be used as either a statement or an expression.%
\footnote{\url{https://openjdk.java.net/jeps/325}}
This enhancement aims to ease the transition to a \code{switch} expression that supports pattern matching.


\related{}
The \nameref{pat:Equals} pattern is a special of \thisp{}.
As we have seen in the \textsf{Instances} section,
The \nameref{pat:ObjectAsArray} pattern can be used occasionally 
to deconstruct the result of the cast.

\end{pattern}
