\begin{pattern}{Family}
Family polymorphism.

\instances{}
The following example%
\footnote{\url{http://bit.ly/pentaho_pentaho-kettle_2FN59J8}}
shows an instance of the \thisp{} pattern.
%
\done{Nate: ?}
%
A cast is applied to the parameter \code{smi} (line 13).
The \code{smi} parameter is declared as \code{StepMetaInterface}, parameter of the \code{stopRunning} method in line 11.
The \code{stopRunning} method is an implementation of the interface method declared in line 3.
%
\done{Nate: Good example.}
%
This cast needs to be done because the developer expects the \code{smi} parameter to be an instance of \code{DynamicSQLRowMeta} when invoking the \code{stopRunning} method on a \code{DynamicSQLRow} object.

%https://lgtm.com/projects/g/pentaho/pentaho-kettle/snapshot/dist-1815472020-1524814812150/files/engine/src/main/java/org/pentaho/di/trans/steps/dynamicsqlrow/DynamicSQLRow.java?sort=name&dir=ASC&mode=heatmap#L281
\begin{minted}[highlightlines=13]{java}
public interface StepInterface extends VariableSpace, HasLogChannelInterface {
  // [...]
  public void stopRunning( StepMetaInterface stepMetaInterface,
          StepDataInterface stepDataInterface ) throws KettleException;
}

public class DynamicSQLRow extends BaseStep implements StepInterface {
  private DynamicSQLRowMeta meta;
  private DynamicSQLRowData data;
  // [...]
  public void stopRunning( StepMetaInterface smi,
        StepDataInterface sdi ) throws KettleException {
    meta = (DynamicSQLRowMeta) smi;
    data = (DynamicSQLRowData) sdi;
    // [...]
  }
}
\end{minted}

The next example%
\footnote{\url{http://bit.ly/apache_orc_2SE4C2m}}
is similar to the previous one.
The \code{masked} parameter is cast to \code{DoubleColumnVector} (line 5).
It is so because the \code{masked} variable is expected to hold an instance of \code{DoubleColumnVector} when the \code{maskData} method is applied to an object of type \code{DoubleIdentity}.

%https://lgtm.com/projects/g/apache/orc/snapshot/dist-1506201906740-1524814812150/files/java/core/src/java/org/apache/orc/impl/mask/DoubleIdentity.java?sort=name&dir=ASC&mode=heatmap#L32
\begin{minted}[highlightlines=5]{java}
public class DoubleIdentity implements DataMask {
  @Override
  public void maskData(ColumnVector original, ColumnVector masked, int start,
                       int length) {
    DoubleColumnVector target = (DoubleColumnVector) masked;
    DoubleColumnVector source = (DoubleColumnVector) original;
    // [...]
  }
}

public interface DataMask {
  // [...]
  void maskData(ColumnVector original, ColumnVector masked,
                int start, int length);
}

\end{minted}

In both previous examples,
cast instances were applied to a parameter in a overriding method.
In the next example,%
\footnote{\url{http://bit.ly/knowm_XChange_2UPPDj9}}
the cast instance is applied to super class field (line 12).
The field is declared in the \code{BaseExchange} class (line 20).
However, the field is initialized with a \code{BitflyerMarketDataService} value in line~5.

%https://lgtm.com/projects/g/knowm/XChange/snapshot/dist-4990076-1524814812150/files/xchange-bitflyer/src/main/java/org/knowm/xchange/bitflyer/BitflyerExchange.java?sort=name&dir=ASC&mode=heatmap#L52
\begin{minted}[highlightlines=12]{java}
public class BitflyerExchange extends BaseExchange implements Exchange {
  // [...]
  @Override
  protected void initServices() {
    this.marketDataService = new BitflyerMarketDataService(this);
    // [...]
  }
  // [...]
  @Override
  public void remoteInit() throws IOException, ExchangeException {
    BitflyerMarketDataServiceRaw dataService =
        (BitflyerMarketDataServiceRaw) this.marketDataService;
    List<BitflyerMarket> markets = dataService.getMarkets();
    exchangeMetaData = BitflyerAdapters.adaptMetaData(markets);
  }
}

public abstract class BaseExchange implements Exchange {
  // [...]
  protected MarketDataService marketDataService;
  // [...]
}
\end{minted}

\footnote{\url{http://bit.ly/apache_calcite_2Tcg6KC}}

%https://lgtm.com/projects/g/apache/calcite/snapshot/dist-21860106-1524814812150/files/core/src/test/java/org/apache/calcite/test/RexImplicationCheckerTest.java?sort=name&dir=ASC&mode=heatmap#L417
\begin{minted}[highlightlines=1]{java}
final RexNode outerFloorCall = f.rexBuilder.makeCall(
    SqlStdOperatorTable.CEIL, innerFloorCall,
    f.rexBuilder.makeFlag(timeUnitRanges.get(j)));
final RexCall simplifiedExpr = (RexCall) defaultSimplifier.apply(outerFloorCall);
\end{minted}

\detection{}

\discussion{}
Another way to see the \thisp{} is when an overriding method uses covariant parameter types.
In \java{}, parameter types are invariant.
That is, parameter types can not be covariant because that would break subtype polymorphism,
and can not be contravariant because that would cause conflict resolution issues with overloading.

\cite{ernstFamilyPolymorphism2001}

\related{}
\nameref{pat:VariableLessSpecificType}

\end{pattern}