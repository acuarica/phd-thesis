\chapter{Casting about in the Dark}\label{cha:casts}

The main goal of a \emph{static} type system
is to prevent certain kinds of errors from happening at run time.
A type system is formulated as a set of constraints that gives any expression or term in a program a well-defined type.
Any program not satisfying the constraints specified by the type system is
simply rejected by the compiler.

Nevertheless, often a static type system is insufficiently precise.
The type checker is necessarily conservative:
it must not accept invalid programs,
but it may reject programs that are valid but whose validity cannot be ensured at compile time.
However, there are situations when the developer has more information
about the program than can be encoded---or encoded easily---into the types.
To that end, programming languages often provide mechanisms to make the typing constraints less strict,
allowing more valid programs at the expense of more errors at run time.

A common mechanism for relaxing the static typing constraints in object-oriented languages is \emph{casting}.
In programming languages with subtyping%
---or \emph{subtype polymorphism}~\citep{cardelliUnderstandingTypesData1985}---
such as \java{}, \csharp{} or \cpp{},
casting allows an expression to be viewed at a different type than the one at which it was defined.
Casts are checked dynamically, \ie, at run-time, to ensure that the object
being cast is an instance of the desired type.

We aim to understand why developers use casts.
Why is the static type system insufficient,
requiring an escape hatch into dynamic type checking?
Specifically, we attempt to answer the following three research questions:

\begin{enumerate}[label=RQ/C\arabic*:,ref=RQ/C\arabic*,leftmargin=3.4\parindent]
\item\label{casts:rq1}{\bf \crqA} \crqAdesc{}
\item\label{casts:rq2}{\bf \crqB} \crqBdesc{}
\item\label{casts:rq3}{\bf \crqC} \crqCdesc{}
\end{enumerate}

To answer these research questions, we devise
\emph{usage patterns}.
Usage patterns are \emph{recurrent programming idioms} used by developers to solve a specific issue.
Usage patterns enable the categorization of different kinds of cast usages and
thus provide insights into how the language is being used by developers in real-world applications.
Our cast usage patterns can be:
\begin{inparaenum}[(1)]
\item a reference for current and future language designers
to make more informed decisions about programming languages,
\eg{},
the addition of \emph{smart casts} in \lang{Kotlin},\footnote{\url{https://kotlinlang.org/docs/reference/typecasts.html\#smart-casts}}
\item a reference for tool builders, \eg{}, by providing more precise or new
  refactoring or code smell analyses,
\item a guide for researchers to test new language features, \eg{},~\cite{wintherGuardedTypePromotion2011} or to carry out controlled
  experiments about programming, \eg{},~\cite{stuchlikStaticVsDynamic2011}, and
\item a guide for developers for best or better practices.
\end{inparaenum}
To answer our research questions,
we empirically study how casts are used by developers.

\section*{Outline}

Section~\ref{sec:casts:casts} provides an introduction to casts in \java{},
while Section~\ref{sec:casts:issues} illustrates the sort of problems developers have when applying casting conversions.
In Section~\ref{sec:casts:methodology} we introduce the methodology we used to analyze casts and to devise cast usage patterns.
Sections~\ref{sec:casts:overview} and~\ref{sec:casts:patterns} present the cast usage patterns and answers our research questions.
Finally, Section~\ref{sec:casts:discussion} discusses the patterns we found,
while Section~\ref{sec:casts:conclusions} concludes.

\input{analysis/casts.def}

\input{chapters/casts/sec-casts-casts}
\input{chapters/casts/sec-casts-issues}
\input{chapters/casts/sec-casts-methodology}
\input{chapters/casts/sec-casts-overview}
\input{chapters/casts/sec-casts-patterns}
\input{chapters/casts/sec-casts-discussion}
\input{chapters/casts/sec-casts-conclusions}