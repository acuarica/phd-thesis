\begin{abstract}
The main goal of a static type system is to prevent certain kinds of errors from happening at run time.
A type system is formulated as a set of constraints that gives any expression or term in a program a well-defined type.
Nevertheless, often the static approximation provided by a type system is not precise enough.
Being static, the analysis done by the type checker needs to be conservative.

However, there are situations when the developer has more information
about the program that is too complex to explain in terms of typing constraints.
To that end, programming languages often provide \emph{mechanisms} that 
make the typing constraints less strict
to permit more programs to be valid,
at the expense of causing more errors at run time.
These mechanisms are essentially two:
\emph{Unsafe Intrinsics} and \emph{Reflective Capabilities}.

We want to understand how and when developers give up these static constraints.
This knowledge can be:
\begin{inparaenum}[a)]
\item a recommendation for current and future language designers
to make informed decisions,
\item a reference for tool builders, \eg{},
by providing more precise or new refactoring analyses,
\item a guide for researchers to test new language features,
or to carry out controlled programming experiments, and
\item a guide for developers for better practices.
\end{inparaenum}

In this dissertation we focus on the \unsafe{} \api{} and cast operator---a subset of unsafe intrinsics and reflective capabilities respectively---in \java{}.
We report two empirical studies to understand how these mechanisms---\unsafe{} \api{} and cast operator---are used by \java{} developers when the static type system becomes too strict.
We have devised usage patterns for both the \unsafe{} \api{} and cast operator.
Usage patterns are recurrent programming idioms to solve a specific issue.
We believe that having usage patterns can help us to better categorize use cases and thus understand how those features are used.

\end{abstract}
