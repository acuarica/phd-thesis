\chapter{Automatic Detection of Patterns using \ql{}}\label{ap:ql}

Query all observations defined.
Columns 'patterns', 'tags', and 'show' need to be concatenated since they might have more than one result.
By concatenating the results in each column, we keep one line for observation.
We sort the results by 'obs' to keep the observations in the same order across runs.
This allows us to easily identify observations every time we re-run the query after adding either a tag or a pattern.

\begin{listing}
\begin{minted}{sql}
from CastExpr ce
select ce
\end{minted}
\caption{Query to fetch all cast expressions in a project.}
\end{listing}

\section{Additional \ql{} Classes and Predicates}

\begin{listing}
\begin{minted}{java}
class Cast extends CastExpr { #\qlbox#
	Type getTargetType() { result = getTypeExpr().getType() }
	Expr getExprOrDef() {
		result = getExpr() or
		exists (VariableAssign def |
			defUsePair(def, getExprOrDef()) and
			result = def.getSource()
		)
	}
}
\end{minted}
\caption{\code{Cast} class definition.}
\label{lst:ql:Cast}
\end{listing}

\begin{listing}
\begin{minted}{java}
class Upcast extends #\qlref{Cast}# { #\qlbox#
	Upcast() {
		getExpr().getType().(RefType).getASupertype+() = getTargetType()
	}
}
\end{minted}
\caption{\code{Upcast} class definition}
\label{lst:ql:Upcast}
\end{listing}

\begin{listing}
\begin{minted}{java}
class ArgumentEx extends Argument { #\qlbox#
	Parameter param;
	ArgumentEx() {
		call.getCallee().getParameter(pos) = param
	}
}
\end{minted}
\caption{\code{ArgumentEx} class definition.}
\label{lst:ql:ArgumentEx}
\end{listing}

\begin{listing}
\begin{minted}{java}
class OverloadedArgument extends #\qlref{ArgumentEx}# { #\qlbox#
	Callable target;
	Callable overload;
	OverloadedArgument() {
		target = call.getCallee() and
		overload = target.getDeclaringType().getACallable() and
		overload.getName() = target.getName() and
		target != overload
	}
	Callable getTarget() { result = target }
	Callable getAnOverload() { result = overload }
}
\end{minted}
\caption{\code{OverloadedArgument} class definition.}
\label{lst:ql:OverloadedArgument}
\end{listing}

\begin{listing}
\begin{minted}{java}
 class VarCast extends #\qlref{Cast}# { #\qlbox#
	Variable var;
	VarCast() { var.getAnAccess() = getExpr() }
	Variable getVar() { result = var }
}
\end{minted}
\caption{\code{VarCast} class definition.}
\label{lst:ql:VarCast}
\end{listing}

\begin{listing}
\begin{minted}{java}	
class ControlByInstanceOfCast extends #\qlref{VarCast}# { #\qlbox#
	InstanceOfExpr iof;
	private ConditionBlock cb;
	ControlByInstanceOfCast() {
		iof = cb.getCondition() and
		cb.controls(getBasicBlock(), true) and
		var.getAnAccess() = iof.getExpr()
	}
	InstanceOfExpr getIof() { result = iof }
}
\end{minted}
\caption{\code{ControlByInstanceOfCast} class definition.}
\label{lst:ql:ControlByInstanceOfCast}
\end{listing}


\begin{listing}
\begin{minted}{java}	
predicate controlByEqualityTest(Expr e, Expr f, Expr c) { #\qlbox#
	exists (ConditionBlock cb, EqualityTest eqe |
		eqe.hasOperands(e, f) and eqe = cb.getCondition() and (
			(eqe.getOp() = " == " and cb.controls(c.getBasicBlock(), true)) or
			(eqe.getOp() = " != " and cb.controls(c.getBasicBlock(), false))
		)
	)
}
\end{minted}
\caption{\code{controlByEqualityTest} predicate definition.}
\label{lst:ql:controlByEqualityTest}
\end{listing}


\begin{listing}
\begin{minted}{java}
predicate controlByEqualsMethod(Expr e, Expr f, Expr c) { #\qlbox#
	exists (ConditionBlock cb, MethodAccess ema |
		ema.getMethod() instanceof EqualsMethod and (
			(ema.getQualifier() = e and ema.getArgument(0) = f) or
			(ema.getQualifier() = f and ema.getArgument(0) = e)
		) and (
			ema = cb.getCondition() and cb.controls(c.getBasicBlock(), true)
		)
	)
}
\end{minted}
\caption{\code{controlByEqualsMethod} predicate definition.}
\label{lst:ql:controlByEqualsMethod}
\end{listing}


\begin{listing}
\begin{minted}{java}
predicate isSubtype(RefType sub, RefType sup) { #\qlbox#
	sub.getASupertype*() = sup
}
\end{minted}
\caption{\code{isSubtype} predicate definition.}
\label{lst:ql:isSubtype}
\end{listing}


\begin{listing}
\begin{minted}{java}	
class GetClassGuardsVarCast extends Cast { #\qlbox#
	GetClassMethodAccess tma;
	GetClassMethodAccess oma;
	GetClassGuardsVarCast() {
		tma.isOwnMethodAccess() and
		oma.getQualifier() = this.(VarCast).getVar().getAnAccess() and
		(
			controlByEqualityTest(tma, oma, this) or
			controlByEqualsMethod(tma, oma, this)
		)
	}
}
\end{minted}
\caption{\code{GetClassGuardsVarCast} class definition.}
\label{lst:ql:GetClassGuardsVarCast}
\end{listing}


\begin{listing}
\begin{minted}{java}	
class AutoValueAnnotation extends Annotation { #\qlbox#
	AutoValueAnnotation() {
		getType().hasQualifiedName("com.google.auto.value", "AutoValue")
	}
}

class AutoValueClass extends Class {
	AutoValueClass() {
		getAnAnnotation() instanceof AutoValueAnnotation and
		isAbstract()
	}
}

class AutoValueGenerated extends Class {
	AutoValueGenerated() {
		count(getASupertype()) = 1 and
		getASupertype() instanceof AutoValueClass
	}
}
\end{minted}
\caption{AutoValue related \ql{} classes.}
\label{lst:ql:AutoValueGenerated}
\end{listing}


\begin{listing}
\begin{minted}{java}
abstract class NewDynamicInstanceAccess extends MethodAccess {}

class NewInstanceAccess extends NewDynamicInstanceAccess {
	NewInstanceAccess() {
		getCallee().hasName("newInstance") and
		(
			getCallee().getDeclaringType() instanceof TypeClass or
			getCallee().getDeclaringType() instanceof TypeConstructor or
			getCallee().getDeclaringType() instanceof TypeArray
		)
	}
}
\end{minted}
\caption{\code{NewDynamicInstanceAccess} class definition.}
\label{lst:ql:NewDynamicInstanceAccess}
\end{listing}


\begin{listing}
\begin{minted}{java}	
abstract class ReflectiveMethodAccess extends MethodAccess {}

class MethodInvokeMethodAccess extends ReflectiveMethodAccess {
	MethodInvokeMethodAccess() {
		getMethod().hasName("invoke") and
		getMethod().getDeclaringType()
						.hasQualifiedName("java.lang.reflect", "Method")
	}
}

class FieldGetMethodAccess extends ReflectiveMethodAccess {
	FieldGetMethodAccess() {
		getMethod().hasName("get") and
		getMethod().getDeclaringType()
						.hasQualifiedName("java.lang.reflect", "Field")
	}
}
\end{minted}
\caption{\code{ReflectiveMethodAccess} class definition.}
\label{lst:ql:ReflectiveMethodAccess}
\end{listing}

\begin{listing}
\begin{minted}{java}
class SetAccessibleMethodAccess extends MethodAccess {
	private Argument flagArgument;
	SetAccessibleMethodAccess() {
		getMethod().hasName("setAccessible") and
		getMethod().getDeclaringType().hasQualifiedName("java.lang.reflect", "AccessibleObject") and
		(
			(getNumArgument() = 1 and flagArgument = getArgument(0)) or
			(getNumArgument() = 2 and flagArgument = getArgument(1))
		)
	}	
	Argument getFlagArgument() {
		result = flagArgument
	}
}

final class SetAccessibleTrueMethodAccess extends SetAccessibleMethodAccess {
	SetAccessibleTrueMethodAccess() {
		getFlagArgument().(BooleanLiteral).getBooleanValue() = true
	}
}
\end{minted}
\caption{\code{SetAccessibleTrueMethodAccess} class definition.}
\label{lst:ql:SetAccessibleTrueMethodAccess}
\end{listing}
