\chapter{Conclusions}
\label{cha:conclusions}

In this thesis I have presented the research I carried out together with my advisors to fullfil the requirements for the \phd{} degree.
We empirically studied how the two mechanisms---\unsafe{} \api{} and casting---are used by developers.
We performed qualitative analyses on source code text.
In particular, we manually inspected source code text to devise usage patterns.

We have discovered common usage patterns for the \java{} Unsafe \api{}.
We discussed several current and future alternatives to improve the
\java{} language.
This work has been published in~\citep{mastrangeloUseYourOwn2015}.
On the other hand, we complement our Unsafe \api{} study with 
our casting study.
We have submitted this study for publication to the \conf{OOPSLA}{19} conference.
We have discovered common usage patterns that involve the cast operator.
Having a taxonomy of usage patterns---for both the \unsafe{} \api{} and casting---can shed light on how \java{} developers give up static type checking.

For our \unsafe{} study,
in response to~\ref{unsafe:rq1} (\urqA{}),
we found that \smu{} is used heavily either directly or indirectly.
In response to~\ref{unsafe:rq2} (\urqB{}),
the results could change if we choose another dataset, \eg{},
\github{}.

For our casting study, in response to~\ref{casts:rq2} (\crqB{}),
we do not claim that our list of patterns is exhaustive.
Although our methodology should ensure that any pattern that occurs more
than 0.1\% of the time has a small probability of being excluded.
In response to~\ref{casts:rq1} (\crqA{}) and~\ref{casts:rq3} (\crqB{})
we assume that casts are uniformly distributed,
otherwise our pattern distribution would not reflect reality.

\section{\java{}'s Evolution}

The \java{} language is evolving constantly.
There are several proposals to improve different aspects of the language.
The proposal JEP 193~\citep{jep193} that introduces Variable Handles is already accepted and included in \java{} 9.
The GC algorithm introduced in JEP 189 Shenandoah~\citep{jep189} is included as a experimental feature in \java{} 12.

There is an ongoing proposal%
\footnote{\url{https://openjdk.java.net/jeps/305}}$^{,}$%
\footnote{\url{https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html}}%
~\citep{jep305} to add pattern matching to the \java{} language.
The proposal explores changing the \code{instanceof} operator in order to support pattern matching.
\java{} 12 extends the \code{switch} statement to be used as either a statement or an expression%
\footnote{\url{https://openjdk.java.net/jeps/325}}$^{,}$%
\footnote{\url{https://openjdk.java.net/jeps/354}}~\citep{jep325,jep354}.
This enhancement aims to ease the transition to a \code{switch} expression that supports pattern matching.

On the other hand,
JEP 191 Foreign Function Interface~\citep{jep191},
JEP 169 Value Objects~\citep{jep169}, and
JEP 300 Augment Use-Site Variance with Declaration-Site Defaults~\citep{jep300}
are still in draft status.

\section{Limitations and Future Work}

Both our \unsafe{} and casting studies rely on manual inspection to devise usage patterns.
The main issue with manual inspection is that rely heavily on the personal experience of the authors.
Different authors could devise different set of patterns.

In our casting study---whenever possible---we have used \ql{} to automatically detect some patterns.
For some other patterns, it is infeasible to perform automatic detection since \ql{}---and the \lgtm{} dataset---currently analyse a given project,
not its dependencies.
Furthermore, some patterns require application-specific knownledge to be detected,
which cannot be expressed in \ql{}.

A possible future work could be to run our detection queries on the entire \lgtm{} database.
This can open up the possibility to devise new usage patterns,
or to refine existing ones.
Moreover,
by running our queries at large-scale we can corroborate---or refute---the distribution of patterns given in both Sections~\ref{sec:casts:overview} and~\ref{sec:casts:patterns}.

Conducting ultra-large scale studies, either on source code or compiled code, is not a trivial task.
There are several factors to consider when doing these kind of studies,
\eg{}, downloading, storing, parsing, compiling,
and analysing software repositories.
Services like \boa{} and \lgtm{} make conducting this kind of studies easier.
In recent versions~\citep{boa-github},
\boa{} added support to conduct studies on open source projects from \github{} and Qualitas Corpus~\citep{temperoQualitasCorpusCurated2010}.
However, at the time we conducted our study on \unsafe{},
this support was not included yet.

We could recast our \unsafe{} study to use \boa{} on the \github{} dataset,
or \lgtm{} through \ql{} queries, although as mentioned above,
we will not be able to analyse project dependencies.
The patterns we have already devised for the \unsafe{} study could be formalized using \ql{}~\citep{avgustinovQLObjectorientedQueries2016}.

To conduct our studies, we have used static analysis.
Static analyses are always more conservative than dynamic analyses.
Another possible future direction could be complement the static analyses with dynamic ones.
For the \unsafe{} study,
we found that it is used in 1\% of the \mavencentral{} artifacts.
Using project dependencies, 25\% of artifacts depend on \smu{}.
A dynamic analysis could actually measure how often the \unsafe{} \api{} is invoked at run-time,
thus giving more precision about its usage.
As for the casting study,
using a dynamic analysis could measure how many casts fail with \code{ClassCastException}.

The two studies we conducted in this thesis analyse a single snapshot of a project,
\ie{}, we did not look into the evolution of a project.
Some patterns could be better understood in terms of their history.
Questions like
\emph{How did they solve this problem before using \unsafe{}?},
or \emph{Why this cast is redundant?}
could be answered by analysing the project's history. 
For instance,
we found that \smu{} is heavily used in only 1\% of analysed artifacts
($48,139$ call sites).
By looking into the project's history would be possible to understand why this happened.
Source code management tools, \eg{}, Git,
maintain a detailed track of changes,
which can point out the precise moment in time when an \unsafe{} operation or cast was introduced in a project.

\section{Lessons Learnt}

Throughout my \phd{} studies I carried out several research projects,
most of them described in this thesis.
Here are a few lessons I learnt in each of them.

\textbf{\unsafe{} \api{}.}
For our \unsafe{} study,
we have engineered a mining software repository infrastructure from scratch.
In particular,
we learnt about the internals of the \mavencentral{} repository.
This requires a considerable amount of time to be implemented properly,
and for a research project can be of little value.

\textbf{Cast operator.}
The cast operator in static typed languages provides a bridge between compile-time and run-time checking.
Developers need to resort to the cast operator due to the inexpressiveness of \java{}'s type system. 

On the other hand, we have discovered \ql{},
a powerful query language for static analysis.
Researchers can use \ql{} in mining software repositories,
while software engineers can use it to find vulnerabilities in their code.

\textbf{\java{} bytecode instrumentation.}
Data-flow analysis is complex.
The bytecode verification through stack map frames introduced in \java{} 6 requires implementing a data-flow analysis at bytecode level.
Making an industrial-strength implementation is not trivial
and requires a lot of careful design.

\textbf{Supercompilation.}
Although not mentioned in this thesis,
I spent a considerable time working on Supercompilation~\citep{turchinConceptSupercompiler1986}.
``Supercompilation is a program optimisation technique that is particularly effective at eliminating unnecessary overheads.''~\citep{mitchellRethinkingSupercompilation2010}.

Although there are several attempts to make Supercompilation mainstream~\citep{mitchellSupercompilerCoreHaskell2007,bolingbrokeSupercompilationEvaluation2010},
still has some drawbacks that makes it impossible to include it in a compiler of industrial-strength.


\section{Artifacts}
\newcommand{\urlartifact}[2]{\item{\footnotesize\url{#1}}: #2}

In each of these research projects,
I have produced several artifacts.
Here are the artifacts mentioned throughout this thesis.

\textbf{\unsafe{} \api{}.}
\begin{itemize}
\urlartifact{https://gitlab.com/acuarica/java-unsafe-analysis}{The complete scripts and results used for this study.}
\urlartifact{http://dx.doi.org/10.1145/2814270.2814313}{Companion artifact that aims to reproduce the results found in this study.
The companion artifact can be found in the \emph{Source Materials} tab in the ACM Digital Library.}
\end{itemize}

\textbf{Cast operator.}
\begin{itemize}
\urlartifact{https://gitlab.com/acuarica/phd-thesis/blob/master/analysis/casts.csv}{Comma-separated values (CSV) table.
Each row represents a cast instance.
This table contains 6 columns.
The last two columns---\col{link} and \col{value}---are the link to the source code file in \lgtm{} and the result of the manual inspection.}
\urlartifact{https://gitlab.com/acuarica/phd-thesis/blob/master/analysis/analysis.r}{The script to process the results of the manual inspection.}
\urlartifact{https://gitlab.com/acuarica/java-cast-queries}{\ql{} detection queries.}
\urlartifact{https://gitlab.com/acuarica/java-cast-inspection}{Early prototype of our cast study using javalang and a custom \javac{} plug-in.}
\urlartifact{https://gitlab.com/acuarica/java-cast-study}{Early prototype of our cast study using JavaParser.}
\end{itemize}

\textbf{Java bytecode instrumentation.}
\begin{itemize}
\urlartifact{https://gitlab.com/acuarica/jnif}{JNIF source code.}
\urlartifact{http://acuarica.gitlab.io/jnif}{JNIF user documentation.}
\end{itemize}

\textbf{Supercompilation.}
\begin{itemize}
\urlartifact{https://gitlab.com/acuarica/hsc}{Our proof of concept of a \haskell{} Supercompiler.}
\end{itemize}
