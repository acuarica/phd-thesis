\chapter{Conclusions}
\label{cha:conclusions}

In this thesis I have presented the research I carried out together with my advisors to fullfil the requirements for the \phd{} degree.
We empirically studied how the two mechanisms---\unsafe{} \api{} and casting---are used by developers.
We performed qualitative analyses on source code text.
In particular, we manually inspected source code text to devise usage patterns.

We have discovered common usage patterns for the \java{} Unsafe \api{}.
We discussed several current and future alternatives to improve the
\java{} language.
This work has been published in~\citep{mastrangeloUseYourOwn2015}.
On the other hand, we complement our Unsafe \api{} study with 
our casting study.
We have submitted this study for publication to the \conf{OOPSLA}{19} conference.
We have discovered common usage patterns that involve the cast operator.
Having a taxonomy of usage patterns---for both the \unsafe{} \api{} and casting---can shed light on how \java{} developers give up static type checking.

\section{\java{}'s Evolution}

The \java{} language is evolving constantly.
There are several proposals to improve different aspects of the language.
The proposal JEP 193~\citep{jep193} that introduces Variable Handles is already accepted and included in \java{} 9.
The GC algorithm introduced in JEP 189 Shenandoah~\citep{jep189} is included as a experimental feature in \java{} 12.

There is an ongoing proposal%
\footnote{\url{https://openjdk.java.net/jeps/305}}$^{,}$%
\footnote{\url{https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html}}%
~\citep{jep305} to add pattern matching to the \java{} language.
The proposal explores changing the \code{instanceof} operator in order to support pattern matching.
\java{} 12 extends the \code{switch} statement to be used as either a statement or an expression%
\footnote{\url{https://openjdk.java.net/jeps/325}}$^{,}$%
\footnote{\url{https://openjdk.java.net/jeps/354}}~\citep{jep325,jep354}.
This enhancement aims to ease the transition to a \code{switch} expression that supports pattern matching.

On the other hand,
JEP 191 Foreign Function Interface~\citep{jep191},
JEP 169 Value Objects~\citep{jep169}, and
JEP 300 Augment Use-Site Variance with Declaration-Site Defaults~\citep{jep300}
are still in draft status.

\section{Limitations and Future Work}

Both our \unsafe{} and casting studies rely on manual inspection to devise usage patterns.
The main issue with manual inspection is that rely heavily on the personal experience of the authors.
Different authors could devise different set of patterns.

For our casting study,
we do not claim that our list of patterns is exhaustive,
although our methodology should ensure that any pattern that occurs more
than 0.1\% of the time has a small probability of being excluded.

In our casting study---whenever possible---we have used \ql{} to automatically detect some patterns.
For some other patterns, it is infeasible to perform automatic detection since \ql{}---and the \lgtm{} dataset---currently analyse a given project,
not its dependencies.
Furthermore, some patterns require application-specific knownledge to be detected,
which cannot be expressed in \ql{}.

A possible direction for future work could be to run our detection queries on the entire \lgtm{} database.
This can open up the possibility to devise new usage patterns,
or to refine existing ones.
Moreover,
by running our queries at large-scale we can corroborate---or refute---the distribution of patterns given in both Sections~\ref{sec:casts:overview} and~\ref{sec:casts:patterns}.

Conducting ultra-large scale studies, either on source code or compiled code, is not a trivial task.
There are several factors to consider when doing these kind of studies,
\eg{}, downloading, storing, parsing, compiling,
and analysing software repositories.
Services like \boa{} and \lgtm{} make conducting these kind of studies easier.
In recent versions~\citep{boa-github},
\boa{} added support to conduct studies on open source projects from \github{} and Qualitas Corpus~\citep{temperoQualitasCorpusCurated2010}.
However, at the time we conducted our study on \unsafe{},
this support was not included yet.
We could recast our \unsafe{} study to use \boa{} on the \github{} dataset,
or \lgtm{} through \ql{} queries, although as mentioned above,
we will not be able to analyse project dependencies.
The patterns we have already devised for the \unsafe{} study could be formalized using \ql{}~\citep{avgustinovQLObjectorientedQueries2016}.

To conduct our studies we have used static analysis.
Static analyses are always more conservative than dynamic analyses.
Another possible future direction could be complement the static analyses with dynamic ones.
For the \unsafe{} study,
we found that it is used in 1\% of the \mavencentral{} artifacts.
Using project dependencies, 25\% of artifacts depend on \smu{}.
A dynamic analysis could actually measure how often the \unsafe{} \api{} is invoked at run-time,
thus giving more precision about its usage.
As for the casting study,
using a dynamic analysis could measure how many casts fail with \code{ClassCastException}.

The two studies we conducted in this thesis analyse a single snapshot of a project,
\ie{}, we did not look into the evolution of a project.
Some patterns could be better understood in terms of their history.
Questions like
\emph{How did they solve this problem before using \unsafe{}?},
or \emph{Why this cast is redundant?}
could be answered by analysing the project's history. 
For instance,
we found that \smu{} is heavily used in only 1\% of analysed artifacts
($48,139$ call sites).
By looking into the project's history would be possible to understand why this happened.
Source code management tools, \eg{}, Git,
maintain a detailed track of changes,
which can point out the precise moment in time when an \unsafe{} operation or cast was introduced in a project.

% What insights did you gain, can you summarize to what degree you answered the RQs?
